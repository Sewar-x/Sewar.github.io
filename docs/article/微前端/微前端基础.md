---
order: 1
category:
  - 微前端
tag:
  - 微前端
---

# 微前端基础

## 什么是微前端？

微前端是一种技术手段及方法策略，旨在通过多个团队独立发布功能的方式，共同构建现代化的Web应用。

它借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用（即微应用），每个微应用都可以独立开发、独立运行、独立部署，然后再将这些小型应用联合为一个完整的应用。

![](../images/image-20240524094651679.png)



## **目标**

微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，确保微应用真正具备独立开发、独立运行的能力。

这种架构既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性。相比一整块的前端仓库，微前端架构下的前端仓库更小、更灵活。

它主要解决了两个问题：

- 1、随着项目迭代应用越来越庞大，难以维护。
- 2、跨团队或跨部门协作开发项目导致效率低下的问题。

![microfroentend](../images/78b3cee6ce36845b.png)



## **特点**

1. **技术栈无关**：微前端架构允许不同的团队使用不同的技术栈进行开发。这意味着，一个项目中可能同时包含使用React、Vue、Angular等不同框架构建的微应用。这种灵活性使得团队可以根据自身专长或项目需求选择合适的技术栈。
2. **独立开发、部署和演进**：每个微应用都是独立的，可以独立地进行开发、测试和部署。这种独立性极大地提高了开发效率，因为不同的团队可以并行工作，互不影响。同时，由于微应用可以独立演进，因此可以更容易地实现增量更新和升级。
3. **增量升级**：在微前端架构中，可以逐个升级微应用，而无需将整个应用一起升级。这种增量升级的特性使得应用的更新更加灵活和可控，减少了升级过程中的风险。
4. **运行时组合**：微前端架构在运行时将多个微应用组合成一个整体应用。这种组合是动态的，可以根据需要进行调整。这使得应用具有更好的可扩展性和可维护性。
5. **主从架构**：微前端通常采用主从架构，其中主应用负责整体应用的路由、状态管理、公共资源加载等，而微应用则负责各自的功能实现。主应用和微应用之间通过约定的接口进行通信和协作。
6. **隔离性**：微前端架构强调微应用之间的隔离性，以确保每个微应用的稳定性和安全性。这包括样式隔离、JavaScript 变量隔离、路由隔离等方面。
7. **弹性扩展**：由于微前端架构的模块化特性，可以方便地添加或移除微应用，以实现应用的弹性扩展。这种扩展性使得应用能够更好地适应业务需求的变化。
8. **提升开发体验**：微前端架构允许开发团队使用各自熟悉的技术栈和工具链进行开发，从而提升了开发体验和效率。同时，由于微应用之间的隔离性，开发过程中不会相互干扰，减少了开发过程中的冲突和错误。

总的来说，微前端架构通过拆分应用为多个独立的微应用，提高了应用的可维护性、可扩展性和开发效率。它允许不同的团队使用不同的技术栈进行开发，并通过约定的接口进行协作和通信，从而实现了一个更加灵活和高效的前端开发模式。

## 常见微前端应用

根据微前端以上特点，微前端应用于以下场景：

### **项目拆分**

- 微前端架构允许不同的团队使用不同的技术栈进行开发。
- 每个微应用都是独立的，可以独立地进行开发、测试和部署。

对比巨石应用一整块的代码仓库，微前端架构下的代码仓库更加**简单**、**轻量**。各个仓库的代码可以基于**业务**、**权限**、**变更的频率**、**组织结构**、**后端微服务**等原则拆分，**界限明确**，**降低耦合**，便于开发人员在开发过程中快速定位源代码，提高开发效率，降低维护成本。

在实际项目中，各个项目会因为各种各样的原因导致使用的技术栈不一样。比如开发框架有 **react**、**vue**、**angular** 等，构建工具有 **webpack**、**rollup**、**parcel** 等，而且版本还可能不一致。使用微前端架构，可以做到将使用不同技术栈(不同版本)的子应用聚合起来。



### 增量升级

> **使用微前端方案很大一部分原因就是为了解决遗留系统迁移问题。**

每个公司项目会存在一些应用随时时间推移和迭代，导致技术落后问题。如：使用 Jquery 开发的项目随时间推移成为技术老旧项目，并且使用 Jquery 实现一些功能复杂。 

我们很难一次性将整个项目重构完成再上线，因此需要将新需求使用新技术，系统原来功能保持不变。

使用微前端可以实现以上增量升级方案。



### 技术栈升级

有些项目，在成立之初使用了当前最新的技术如 Vue2。但是随着技术的发展，Vue 已经更新到了Vue3，但项目由于一直在迭代，还是使用  Vue2。直接全部重构，肯定是不现实的，费时费力不说，风险也大。

针对这种情况，我们可以重起一个应用，使用 Vue3 循序渐进的重构应用，然后使用微前端方案将新旧应用聚合在一起。

 

## 缺点

1. **复杂性增加**：微前端架构需要处理多个独立的应用，每个应用都有自己的技术栈、构建流程和依赖关系。这可能导致整体架构的复杂性增加，需要额外的管理和协调工作。
2. **性能问题**：在微前端中，每个应用都可能需要加载和初始化自己的依赖，这可能导致页面加载时间增加。同时，页面之间的跳转可能会引入额外的延迟。因此，需要仔细优化和考虑性能问题。
3. **数据共享和状态管理**：在微前端中，不同的应用可能来自不同的团队，它们之间的数据共享和状态管理可能变得复杂。需要找到合适的方法来共享数据和状态，避免数据不一致问题。
4. **开发门槛高**：实现微前端架构需要一定的技术积累和实践经验，对于新手来说可能存在一定的学习门槛。此外，由于涉及到多个应用的整合和协作，因此也需要具备一定的团队协作和沟通能力。

---



## 微前端带来问题

通过微前端常见的解决方案可以归纳一些微前端存在的问题：

* 样式冲突
* 脚本互斥
* 消息通信
* 公共依赖加载
* 微应用打开速度慢（通常使用 **资源预加载** 解决）

### 脚本互斥问题

在微前端技术方案中，脚本互斥问题指的是不同微前端应用之间因为加载和执行脚本而导致的冲突和干扰。这些冲突可能来自于全局变量的污染、DOM 结构的冲突、事件监听的冲突等方面。

**脚本互斥问题的原因**

1. **全局变量污染**：不同的微前端应用可能使用了相同的全局变量名，导致一个应用修改了全局变量的值，影响到了另一个应用。
2. **DOM 结构冲突**：不同的微前端应用可能尝试操作相同的 DOM 元素，或者因为样式冲突导致 DOM 元素的表现不一致。
3. **事件监听冲突**：不同的微前端应用可能都监听了相同的事件，导致事件处理函数之间的冲突和干扰。

**解决方案**

1. **沙箱隔离：**
   - 使用 JavaScript 的沙箱机制，为每个微前端应用创建一个独立的全局环境，避免全局变量的污染。
   - 这可以通过 Proxy、Web Workers 或者 iframe 等技术实现。
   - 例如，qiankun 框架就采用了基于 Proxy 的沙箱实现，确保每个微前端应用都在自己的环境中运行。
2. **DOM 隔离：**
   - 为每个微前端应用分配一个独立的 DOM 容器，避免 DOM 结构的冲突。
   - 这可以通过在主应用中预留一些空的 DOM 节点，然后在加载微前端应用时将其挂载到这些节点上实现。
   - 同时，还需要注意样式隔离，避免不同微前端应用的样式相互干扰。
3. **事件监听隔离：**
   - 为每个微前端应用分配独立的事件监听空间，避免事件监听的冲突。
   - 这可以通过在事件监听器中添加命名空间、使用自定义事件或者事件委托等技术实现。
   - 例如，可以约定每个微前端应用只监听以自己命名空间为前缀的事件，从而避免冲突。



### 应用隔离方案

微前端的应用隔离主要指的是在微前端架构中，将不同的微前端应用程序隔离开来，以确保它们之间不会相互影响或干扰。

应用隔离主要分两种情况：

- 一种是 `主应用与微应用`之间的隔离；
- 一种是 `微应用与微应用`之间的隔离；

应用间所隔离的主要是：

* **Javascript 的沙箱隔离** 
* **CSS 的样式隔离**

#### **JavaScript的沙箱隔离**

沙箱是一种安全机制，目的是让程序运行在一个相对独立的隔离环境，使其不对外界的程序造成影响，保障系统的安全。

在微前端中，不同开发团队的子应用很难通过规范约束他们使用全局变量，因此沙箱机制可以确保每个微前端应用都在自己的环境中运行，互不干扰。

每当微应用的  JavaScript 被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如 jQuery 脚本运行后，会在 Window 上挂载一个 window.$ 对象，对于其他库 React，Vue 也相同。

为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）；

<img src="../images/沙箱隔离机制.png" alt="沙箱隔离机制" style="zoom:50%;" />

##### **实现沙箱隔离机制方法**

微前端中常见的实现沙箱的方法主要有以下几种：

1. **基于 iframe 的沙箱：**
   - 在前端中，`iframe` 是一个重要的 HTML 标签，它允许将另一个 HTML 文档嵌入到当前的 HTML 文档中。
   - 通过 `iframe` 对象，我们可以将原生浏览器对象通过 `contentWindow` 取出来，这个对象天然具有所有的属性，并且与主应用的环境隔离。
   - 但是，使用 `iframe` 也有一些缺点，比如性能开销、跨域限制、样式同步问题等。
2. **基于 JavaScript 的作用域和闭包机制的沙箱：**
   - JavaScript 中的每个变量都有自己的作用域，作用域之间是相互独立的。
   - 闭包机制可以使一个函数内部的变量被外部访问，但外部的变量不能被内部访问。
   - 利用这些特性，可以创建出独立的运行环境，实现代码的隔离和限制。
3. **基于 Proxy 的沙箱：**
   - Proxy 沙箱是微前端框架（如 qiankun）中的一种常见实现方式。
   - 它使用 JavaScript 的 Proxy 对象创建一个全局对象的代理，通过这个代理隔离子应用对全局对象的影响。
   - 当子应用试图修改全局对象时，这个代理会拦截这个操作，将修改应用到代理对象上，而不是全局对象上。
   - 这样，子应用就可以在沙箱中自由地修改全局对象，而不会影响到其他子应用。
4. **基于快照的沙箱：**
   - 这也是 qiankun 等框架提供的一种沙箱实现方式。
   - 它在子应用加载时对全局对象进行快照，保存全局对象的当前状态。
   - 然后，在子应用卸载时，将全局对象恢复到加载时的状态。
   - 这种方式也能确保子应用在沙箱中自由地修改全局对象，而不会影响到其他子应用。
5. **Shadow DOM：**
   - 虽然 Shadow DOM 主要是用于封装组件的样式和行为，但它也可以用于实现某种程度的沙箱效果。
   - Shadow DOM 提供了将 DOM 树的一部分（称为“shadow tree”）附加到任何元素（称为“host element”）的能力，并且这个 shadow tree 是封装的，不会影响到外部 DOM 树。



#### **CSS的样式隔离**

由于在微前端场景下，不同技术栈的子应用会被集成到同一个运行池中，所以必须在框架层确保各个子应用之间不会出现样式互相干扰的问题。

例如：一个团队的微应用的样式表为 `h2 { color: black; }`，而另一个团队的微应用则为 `h2 { color: blue; }`，而这两个选择器都附加在同一页面上，就会冲突；

为了避免这个问题，常见的解决方案有：

- 严格的命名约定，例如 BEM；
- CSS Module；
- 各种 CSS-in-JS 库；
- shadow DOM；

另外，一些微前端框架（如qiankun）也提供了样式隔离的功能。



---





### 公共依赖加载问题

在微前端技术方案中，公共依赖加载是一个重要且需要仔细考虑的问题。

公共依赖指的是被多个微前端应用所共同使用的库或框架，如 React、Vue、jQuery 等。

**问题概述**

在微前端架构中，每个微前端应用可能都会依赖一些公共的库或框架。如果这些公共依赖没有被妥善管理，就可能导致以下问题：

1. **重复加载**：如果每个微前端应用都自行加载自己所需的公共依赖，那么这些依赖可能会被多次加载到浏览器中，导致资源的浪费和性能的下降。
2. **版本冲突**：不同的微前端应用可能依赖相同公共依赖的不同版本，这可能导致版本冲突和不可预测的行为。
3. **开发效率低下**：开发人员需要在每个微前端应用中单独管理公共依赖，这会增加开发成本和维护成本。

**解决方案**

为了解决公共依赖加载问题，微前端技术方案中通常采取以下策略：

1. **依赖预加载：**
   - 在主应用中预加载所有微前端应用可能用到的公共依赖。
   - 可以通过在主应用的 HTML 中预先引入这些依赖的脚本标签来实现。
   - 这种方式可以确保公共依赖只被加载一次，避免了资源的浪费。
2. **分布式依赖管理：**
   - 每个微前端应用自己管理其依赖，并在构建时通过 Webpack 等工具将依赖打包到子应用的 bundle 中。
   - 这种方式保持了子应用的独立性，但也可能导致依赖冲突和重复加载的问题。
   - 因此，需要配合其他策略来避免这些问题，如使用相同的公共依赖版本、利用 Webpack 的 externals 配置等。
3. **使用微前端框架：**
   - 一些微前端框架（如 qiankun、single-spa）提供了依赖管理的解决方案。
   - 这些框架允许子应用导出和导入生命周期钩子，并在主应用中加载和管理子应用的资源，包括依赖。
   - 通过框架的依赖管理机制，可以确保公共依赖只被加载一次，并且避免了版本冲突的问题。
4. **共享依赖：**
   - 所有微前端应用共享同一个依赖版本。
   - 这种方式可以减少重复的依赖文件加载，提高页面性能。
   - 但需要管理依赖版本的一致性，并解决依赖冲突的问题。
   - 可以通过构建工具（如 Webpack）的 SplitChunksPlugin 插件来提取公共依赖到一个单独的 bundle 中，并由所有微前端应用共享。
5. **动态导入：**
   - 使用 JavaScript 的动态导入（dynamic imports）功能来按需加载公共依赖。
   - 这种方式可以在需要时才加载公共依赖，进一步减少资源的浪费。
   - 但需要注意浏览器的兼容性和构建工具的配置。

**总结**

在微前端技术方案中，公共依赖加载是一个需要仔细考虑的问题。通过依赖预加载、分布式依赖管理、使用微前端框架、共享依赖和动态导入等策略，可以有效地解决公共依赖加载问题，提高微前端应用的性能和可维护性。





### 消息通信问题

在微前端架构中，每个微前端应用都是独立的，它们有自己的运行环境和生命周期。

然而，这些微前端应用之间又需要相互通信以协同工作，比如共享数据、触发事件等。这就带来了消息通信的问题。

**常见的消息通信方式**

1. **事件总线（Event Bus）：**
   - 主应用可以创建一个事件总线，用于发布和订阅事件。
   - 各个微应用可以通过订阅事件的方式获取其他微应用发送的消息，也可以通过发布事件的方式向其他微应用发送消息。
   - 事件总线需要提供一个全局可访问的接口，以便微应用可以方便地与之交互。
2. **全局状态管理（Global State）：**
   - 主应用可以提供一个全局状态管理的机制，如使用 Redux、MobX 等状态管理库。
   - 各个微应用可以通过读取和修改全局状态的方式进行通信。
   - 这种方式需要确保全局状态的安全性和一致性，避免多个微应用同时修改同一块状态导致的问题。
3. **Web 组件通信：**
   - 微前端架构中的各个微应用可以使用 Web 组件进行通信。
   - 主应用可以将需要传递的数据作为属性传递给微应用的 Web 组件，微应用可以通过监听属性变化的方式获取数据。
   - Web 组件通信方式适用于数据传递和简单的交互场景。
4. **Ajax/HTTP 请求：**
   - 不同微应用之间可以通过 Ajax 或 HTTP 请求的方式进行通信。
   - 一个微应用可以向主应用发送请求，主应用可以将请求转发给其他微应用，并将响应返回给发起请求的微应用。
   - 这种方式适用于跨域通信和数据交换的场景。
5. **postMessage：**
   - 跨文档通信（Cross-document Messaging）API 提供了 `postMessage` 方法，允许来自不同源的文档（iframe、window、worker）之间进行安全通信。
   - 通过 `postMessage`，微前端应用可以在不破坏浏览器同源策略的前提下进行通信。

**消息通信的最佳实践和注意事项**

1. **明确通信协议：**
   - 在微前端架构中，需要明确不同微前端应用之间的通信协议，包括事件名、数据格式等。
   - 这有助于确保通信的准确性和可靠性。
2. **避免共享状态：**
   - 尽量避免在微前端之间共享状态，因为这可能导致状态管理的复杂性和难以预测的问题。
   - 如果确实需要共享状态，建议使用全局状态管理库来确保状态的安全性和一致性。
3. **使用异步通信：**
   - 在微前端之间使用异步通信方式（如事件总线、Ajax 请求等），以确保通信的灵活性和可扩展性。
   - 异步通信方式可以避免阻塞主线程和提高应用的响应速度。
4. 处**理通信错误：**
   - 在实现微前端通信时，需要考虑通信错误的处理和重试机制。
   - 这有助于确保在通信失败时应用能够正常运行并尝试重新建立连接。
5. **测试与监控：**
   - 对微前端通信进行充分的测试和监控，以确保通信的稳定性和可靠性。
   - 通过测试可以发现潜在的通信问题并及时修复；通过监控可以实时了解通信状态并做出相应调整。



---



## 微前端技术方案



| 技术方案                       | 特点                                                         | 优点                                                         | 缺点                                                         |
| :----------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **基于Web Components**         | 使用Web Components的四个主要技术：Custom Elements、Shadow DOM、HTML Templates、HTML Imports。将前端应用程序拆分为多个Web Components。 | 标准化技术，具有广泛的浏览器支持<br />高内聚、低耦合，易于维护和扩展良好的封装性和隔离性 | 需要一定的学习成本来掌握Web Components的使用浏览器兼容性问题<br />可能需要额外处理不支持全局样式和JavaScript的共享 |
| **基于iframe**                 | 使用iframe将每个微前端应用嵌入到主框架中，实现隔离。         | 简单、快速<br />实现良好的隔离性，避免样式和全局变量的冲突<br />支持跨域通信 | 性能开销较大，因为每个iframe都是独立的浏览器上下文<br />难以共享资源，如全局状态、数据等页面刷新和导航问题 |
| **基于单页面应用（SPA）**      | 通过在主框架中配置路由，根据路由加载不同的微前端应用。       | 简单易用，适用于SPA架构<br />支持全局状态和数据共享<br />易于集成第三方库和框架 | 隔离性较差，样式和全局变量可能冲突<br />对SPA架构有依赖，不适合传统多页面应用<br />需要处理路由冲突和嵌套问题 |
| **基于微服务网关路由分发**     | 使用微服务网关作为微前端应用的代理和调度器，根据请求转发到不同的微前端应用。 | 支持跨域请求和API网关功能<br />可以实现统一的身份认证和权限管理<br />灵活性强，支持多种微前端技术 | 实现复杂，需要配置和维护微服务网关<br />对网络通信有较高要求可能增加额外的性能开销 |
| **基于自定义元素和Shadow DOM** | 使用自定义元素封装微前端应用，并使用Shadow DOM提供隔离性。   | 高内聚、低耦合，易于维护和扩展良好的封装性和隔离性<br />支持自定义元素和Shadow DOM的浏览器兼容性较好 | 需要一定的学习成本来掌握自定义元素和Shadow DOM的使用<br />不支持全局样式和JavaScript的共享可能受到浏览器兼容性的限制 |



---



## 微前端框架

|       技术框架        | 特点                                                         | 优点                                                         | 缺点                                                         |
| :-------------------: | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|    **Single-SPA**     | 最早的微前端框架之一，基于路由和生命周期钩子实现微前端。     | 简单易用，轻量级<br/>支持多种前端框架（React, Vue, Angular等）<br/>清晰的生命周期管理 | 隔离性较弱，样式和全局变量可能冲突<br/>需要手动处理路由冲突和嵌套问题<br/>不自带通信机制，需要额外实现 |
|      **qiankun**      | 由蚂蚁金服开源，基于Single-SPA封装的微前端框架，提供了更加完善的隔离和通信机制。 | 兼容性强，支持主流前端框架<br/>提供沙箱机制，实现真正的样式隔离和JS隔离<br/>内置通信机制，方便微应用间通信 | 相对较重，可能引入一些不必要的依赖<br/>学习成本较高，需要理解其沙箱和通信机制<br/>对主框架有一定侵入性 |
|  **Micro-Frontends**  | 这是一个概念或策略，而不是具体的框架，它描述了将前端拆分成多个独立可部署应用的技术方法。 | 技术栈无关，支持多团队并行开发<br/>独立开发、部署、升级<br/>可维护性和可扩展性好 | 实现复杂，需要处理多个应用的集成和通信<br/>可能引入额外的性能开销<br/>需要额外的管理和监控机制 |
| **Module Federation** | Webpack 5 引入的新特性，允许在构建时动态地加载其他应用中的模块。 | 支持运行时动态加载模块<br/>可以实现跨应用代码共享<br/>与Webpack紧密集成，易于配置和使用 | 需要Webpack 5支持<br/>配置相对复杂<br/>可能引入额外的构建和部署复杂性 |
|        **EMP**        | 由饿了么前端团队开源的微前端解决方案，提供了完整的开发、构建、部署和监控能力。 | 功能全面，支持从开发到部署的全流程<br/>提供多种通信机制和隔离策略<br/>易于集成和扩展 | 相对较新，社区支持可能不如其他成熟框架<br/>学习成本较高，需要理解其整体架构和组件<br/>可能引入额外的依赖和配置复杂性 |
|       **wujie**       | 由某公司或组织开源的微前端框架，具有特定的设计和功能特点。   | （假设）提供丰富的API和插件机制<br/>（假设）支持多种通信方式和数据共享<br/>（假设）具有高性能和可扩展性 | （假设）可能对于某些场景或技术栈支持不够完善<br/>（假设）学习成本可能较高，尤其是对于新手开发者<br/>（假设）社区支持可能相对较少 |



