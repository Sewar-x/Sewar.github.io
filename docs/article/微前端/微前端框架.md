---
order: 3
category:
  - 微前端
tag:
  - 微前端 微前端框架
---

# 微前端框架

|                           技术框架                           | 特点                                                         | 优点                                                         | 缺点                                                         | start |
| :----------------------------------------------------------: | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | ----- |
| [**Single-SPA**](https://zh-hans.single-spa.js.org/docs/getting-started-overview) | 最早的微前端框架之一<br />基于路由和生命周期钩子实现微前端。 | 1.简单易用，轻量级<br/>2.支持多种前端框架（React, Vue, Angular等）<br/>3.清晰的生命周期管理 | 1.隔离性较弱，样式和全局变量可能冲突<br/>2.需要手动处理路由冲突和嵌套问题<br/>3.需要手动处理子应用之间的通信和状态同步<br />4.不自带通信机制，需要额外实现<br />5.缺乏路由管理和状态管理的内置支持 | 13.1k |
|      [**qiankun**](https://qiankun.umijs.org/zh/guide)       | 由蚂蚁金服开源<br />**基于Single-SPA封装**的微前端框架<br />提供了更加完善的隔离和通信机制。 | 1.兼容性强，支持主流前端框架<br/>2.支持多种前端框架和构建工具<br />3.提供沙箱机制，实现真正的样式隔离和JS隔离<br />4.提供了丰富的功能和插件，如路由管理、状态管理、沙箱隔离等<br/>5.内置通信机制，方便微应用间通信<br />6.子应用可独立开发、独立部署，不会相互影响 | 1.相对较重，可能引入一些不必要的依赖<br/>2.学习成本较高，需要理解其沙箱和通信机制<br/>3.对主框架有一定侵入性 | 15.5k |
|    [**MicroApp**](https://micro-zoe.github.io/micro-app/)    | 一个轻量级的微前端框架，专注于解决微前端应用之间的通信和状态同步问题<br />结合CustomElement将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染 | 1.简单易用<br />2.提供了强大的通信和状态同步功能<br /> 3.支持多个前端框架 | 1.功能相对较少，可能不适用于复杂的微前端场景                 | 5.3k  |
|        [**无界**](https://wujie-micro.github.io/doc/)        | 基于 WebComponent 容器 + iframe 沙箱的微前端框架             | 极致预加载、预执行，页面秒开无白屏、丝滑般切换<br />支持子应用保活、内嵌、去中心化通信、多应用激活<br />基于 WebComponent 和 iframe，原生物理隔离<br />避免 with 语句运行代码，整体的运行性能接近原生<br />主、子应用无需做任何适配，开箱即用 |                                                              | 3.8k  |
|             [**EMP**](https://emp2.netlify.app/)             | 由饿了么前端团队开源的微前端解决方案，提供了完整的开发、构建、部署和监控能力。<br />基于 webpack 5 module federation 的微前端方案<br />聚焦微前端生态闭环建设,v2.7全面支持模块共享热更 | 功能全面，支持从开发到部署的全流程<br/>提供多种通信机制和隔离策略<br/>易于集成和扩展<br />提供了模块联邦的功能，支持跨应用共享代码和组件<br />结合webpack5、Module Federation的丰富项目实践、建立三层共享模型<br />结合webpack 5 中心化缓存、提升整体构建速度.<br />对 TypeScript、JSX、CSS、Less、Sass 等支持开箱即用。<br />可选 “多页应用” 或 “库” 模式的预配置 webpack 构建.<br />在开发和构建之间共享 webpack chain 插件接口.<br />提供灵活的api、Plugin以及完整的类型提示. | 相对较新，社区支持可能不如其他成熟框架<br/>学习成本较高，需要理解其整体架构和组件<br/>可能引入额外的依赖和配置复杂性 | 2.3k  |
|       [**Garfish**](https://www.garfishjs.org/guide/)        |                                                              |                                                              |                                                              | 2.4k  |

---

## 微前端框架常见功能说明

| 功能 | 说明 |
| --- | --- |
| 子应用管理 | 管理和加载子应用，包括注册、启动、卸载等操作。 |
| 路由管理 | 管理前端应用的路由，支持子应用之间的路由跳转和共享。 |
| 数据通信 | 提供子应用之间的数据通信机制，如事件总线、状态管理等。 |
| JS沙箱 | 隔离子应用的JavaScript运行环境，防止不同子应用之间的全局变量冲突。 |
| 样式隔离 | 隔离子应用的样式，防止样式污染和冲突。 |
| 元素隔离 | 隔离子应用的DOM元素，防止DOM结构冲突和干扰。 |
| 静态资源处理 | 处理子应用的静态资源，如图片、字体、脚本等。 |
| 预加载和懒加载 | 支持子应用的预加载和懒加载，提高页面加载速度和用户体验。 |
| 缓存管理 | 管理子应用的缓存，提高应用性能和响应速度。 |
| 权限管理 | 提供子应用的权限管理功能，如权限验证、角色管理等。 |
| 跨域通信 | 支持跨域的子应用通信，如跨域`iframe`通信等。 |
| 插件系统 | 提供插件系统，支持扩展微前端框架的功能和定制开发。 |
| 降级兼容处理 | 提供降级和兼容性处理机制，确保在不同浏览器和环境下都能正常运行。 |
| 错误处理和监控 | 提供错误处理和监控机制，帮助开发人员快速定位和解决问题。 |
| 应用状态管理 | 管理微前端应用的全局状态，支持状态共享和同步。 |
| 应用嵌套 | 支持子应用的嵌套使用，构建复杂的微前端应用架构。 |
| 自定义配置 | 提供自定义配置选项，满足不同项目的需求。 |
| 文档和社区支持 | 提供详细的文档和社区支持，帮助开发人员快速上手和解决问题。 |



## 功能对比



| 特性/框架          |   Single-SPA   |      qiankun       |     MicroApp     |          无界           |             EMP              |
| :----------------- | :------------: | :----------------: | :--------------: | :---------------------: | :--------------------------: |
| 使用方案           |                | **基于Single-SPA** | `类WebComponent` | `WebComponent + iframe` | `webpack5 module federation` |
| IE支持             | ✓ (需polyfill) |   ✓ (需polyfill)   |  ✓ (需polyfill)  |  ✓ (自动切换成iframe)   |        ✓ (需polyfill)        |
| 接入成本           |       低       |         中         |        低        |           高            |              中              |
| 开箱即用           |       ✓        |         ✗          |        ✗         |            ✓            |              ✓               |
| 数据通信机制       |     自定义     |       自定义       |      自定义      |         自定义          |            自定义            |
| JS沙箱             |       ✗        |         ✓          |        ✓         |     ✓ (基于iframe)      |              ✓               |
| 样式隔离           | ✗ (需额外处理) |         ✓          |        ✓         | ✓ (基于webcomponent实现 |              ✓               |
| 元素隔离           |       ✗        |         ✗          |        ✓         |   ✓ (基于Shadow DOM)    |              ✓               |
| 静态资源地址补全   |       ✗        |         ✗          |        ✓         |            ✓            |              ✓               |
| 预加载             |       ✗        |         ✓          |        ✓         |            ✗            |              ✓               |
| keep-alive         |       ✗        |         ✓          |        ✓         |            ✓            |              ✓               |
| 应用共享同一个资源 |       ✓        |         ✓          |        ✓         |            ✓            |              ✓               |
| 应用嵌套           |       ✓        |         ✓          |        ✓         |            ✓            |              ✓               |
| 插件系统           |       ✗        |         ✓          |        ✓         |            ✗            |              ✓               |
| 子应用不改造接入   |       ✓        |         ✓          |        ✓         |            ✗            |              ✓               |
| 内置降级兼容处理   |       ✗        |         ✓          |        ✓         | ✓ (基于Web Components)  |              ✓               |

---



## [**Single-SPA**](https://zh-hans.single-spa.js.org/docs/getting-started-overview)

[Single-spa](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsingle-spa%2Fsingle-spa) 是最早的微前端框架，兼容多种前端技术栈；

概念：Single-spa 是一个将多个单页面应用聚合为一个整体应用的  JavaScript 微前端框架；

我们都知道 spa 应用 的理念是让独立的应用程序组成一个完整的页面，`Single-spa` 并不用依赖于单个框架和每个特性，而是你可以在不同的新框架随意使用；

简单来说就是一个聚合，使用这个库可以让你的应用可以 使用多个不同的技术栈（vue、react、angular等等) 进行同步开发，最后使用一个公用的路由去实现完美的切换；

[快速体验入口](https://link.juejin.cn?target=https%3A%2F%2Fsingle-spa.surge.sh)

**优点：**

- 敏捷性 - 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；
- 技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权；
- 增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略
- 更快交付客户价值，有助于持续集成、持续部署以及持续交付；
- 维护和 bugfix 非常简单，每个团队都熟悉所维护特定的区域；

**缺点：**

- **需要改造子应用接入 Single-SPA**，对原项目具有侵入性；（**需要修改原项目，使原项目需要暴露接入协议**）
- 无通信机制
- 不支持 Javascript 沙箱
- 样式冲突
- 无法预加载

> 正是因为有了 `Single-spa`，才让大部分微前端框架得以出现，所以以下所讲的微前端框架几乎都拥有 `Single-spa` 的优点



### **应用加载方案**

single-spa 通过**路由劫持**实现应用的加载 (**采用SystemJS**)，提供应用间公共组件加载及公共业务逻辑处理。

子应用需要暴露固定的钩子 bootstrap、mount、unmount 接入协议。

### **通信机制**

Single-SPA的通信机制主要通过 p**rops 传递数据**、**路由事件**和自定义事件来实现微应用之间的数据共享和交互。

#### **应用间通信的主要方式：**

- **通过props传递数据**：Single-SPA提供了`getProps`和`setProps`的API，允许主应用向子应用传递数据，或者子应用向主应用请求数据。这种方式实现了父子应用之间的简单数据通信。
- **路由事件**：当路由发生变化时，Single-SPA会触发相应的事件。微应用可以监听这些路由事件，根据路由的变化来加载或卸载相应的微应用，或者执行其他逻辑。
- **自定义事件**：Single-SPA允许微应用之间通过`addEventListener`和`removeEventListener`来监听和触发自定义事件，从而实现更复杂的应用间通信。

#### **详细步骤：**

1. 数据传递：
   - 主应用在加载子应用时，可以通过`setProps`方法向子应用传递数据。
   - 子应用可以在其生命周期钩子（如`mount`）中，通过`getProps`方法获取主应用传递的数据。
2. 路由事件监听：
   - 微应用可以通过Single-SPA提供的路由监听机制，监听路由的变化，并在路由变化时执行相应的逻辑。
3. 自定义事件监听与触发：
   - 微应用可以使用`addEventListener`方法监听其他微应用或主应用触发的自定义事件。
   - 当需要与其他微应用或主应用通信时，可以使用`dispatchEvent`或类似的方法触发自定义事件，并传递相关数据。



### **SystemJS**

> SystemJS是一个通用的模块加载器，它支持加载多种模块格式，如AMD、CommonJS、UMD等。
>
> 它的主要功能是在运行时按需加载模块，并为每个模块创建独立的作用域，以防止模块之间的全局污染。
>
> SystemJS还提供了配置选项和插件系统，可以根据需求进行灵活的定制和扩展。

在微前端架构中，SystemJS 可以用于加载微应用的入口文件（通常是包含微应用初始化和挂载逻辑的 JavaScript 文件）。当主应用需要加载某个微应用时，它会使用 SystemJS 来动态加载并执行该微应用的入口文件。

#### **基本用法示例**

1. **安装SystemJS**：

   - 通过npm进行安装：`npm install systemjs`

2. **配置SystemJS**：

   - 在项目的根目录下创建一个配置文件，例如`systemjs.config.js`，用于配置模块加载器和打包选项。

3. **配置示例**（参考自参考文章2）：

   ```javascript
   // systemjs.config.js  
   System.config({  
     baseURL: '/', // 指定模块加载的基础路径  
     paths: {  
       'app/*': 'src/app/*', // 定义模块的路径别名，方便引用  
       'vendor/*': 'src/vendor/*',  
       'npm:*': 'node_modules/*'  
     },  
     map: {  
       'app': 'app', // 指定模块的映射关系  
       'rxjs': 'npm:rxjs',  
       'angular': 'npm:@angular/core/bundles/core.umd.js'  
     },  
     packages: {  
       'app': { // 定义模块的包配置  
         main: 'main.js', // 入口文件  
         defaultExtension: 'js' // 默认扩展名  
       },  
       'rxjs': {  
         defaultExtension: 'js'  
       }  
     }  
   });
   ```

4. **使用SystemJS加载模块**：

   - 在HTML文件中引入SystemJS库和配置文件：

     ```html
     <script src="node_modules/systemjs/dist/system.js"></script>  
     <script src="systemjs.config.js"></script>
     ```

   - 然后使用

     ```
     System.import
     ```

     方法来动态加载模块：

     ```javascript
     System.import('app/main.js').then(function(module) {  
       // 模块加载完成后执行的代码  
       // 可以使用加载的模块进行后续操作  
     }).catch(function(err) {  
       // 处理模块加载错误  
       console.error('Module load failed', err);  
     });
     ```



### 拆分应用

在大型微服务系统中，我们需要将前端拆解成一个个小应用和基座应用。

（single-spa基础配置和每个应用程序都应该有自己的git仓库）

微前端拆分应用后的管理应用模式主要包括以下几种：

1. **基座模式：**
   - 通过一个主应用（基座）来管理所有子应用。主应用可以只是单纯的基座功能，也可以带有业务功能，如用户登录、菜单管理等。
   - 只需要设计好对应的应用加载机制，如何时加载、何时卸载等。
   - 这种模式下，每个子应用可以独立开发、独立部署，而整体应用通过主应用进行整合和统一管理。
2. **NPM包模式：**
   - 将微前端应用作为NPM包进行发布和管理。
   - 每个微前端应用都可以作为一个独立的NPM包，具有自己的版本控制和依赖管理。
   - 通过NPM包的方式，可以方便地进行微前端应用的分发、更新和依赖管理。
3. **动态加载模块模式：**
   - 这种模式下，微前端应用不是通过传统的路由跳转或者iframe嵌入的方式进行加载，而是通过动态加载模块的方式实现。
   - 例如，可以使用JavaScript的动态导入（dynamic import）功能，在运行时根据需求加载对应的微前端应用模块。
   - 动态加载模块可以提高应用的加载速度和用户体验，同时也能够实现微前端应用的按需加载和卸载。

| 比较维度     | 基座模式（Monorepo）                                         | NPM包                                                        | 动态加载模块                                                 |
| ------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 特点         | 使用single-spa的最简单方法是拥有一个包含所有代码的仓库。<br />通常只有一个`package.json`,一个的webpack配置，产生一个包，<br />它在一个html文件中通过`<script>`标签引用。 | 创建一个父应用，npm安装每个single-spa应用。<br />每个子应用在一个单独的代码仓库中，负责每次更新时发布一个新版本。<br />当single-spa应用发生更改时，根应用程序应该重新安装、重新构建和重新部署 | 创建一个父应用，允许子应用单独部署。<br />为了实现这一点，创建一个manifest文件，当子应用部署更新时，它控制子应用的“上线”版本及加载的JavaScript文件 |
| 优势         | 1.最容易部署<br /> 2.[单一版本（monorepo）控制的优点](https://danluu.com/monorepo/) | 1.npm安装对于开发中更熟悉，易于搭建。 <br />2.独立的npm包意味着：每个应用在发布到npm仓库之前可以分别打包。 |                                                              |
| 劣势         | 1.对于每个单独的项目来说，一个Webpack配置和package.json意味着的灵活性和自由度不足。<br /> 2.当你的项目越来越大时，打包速度越来越慢。<br /> 3.构建和部署都是捆绑在一起的，这要求固定的发版计划，而不能临时发布。 | 1.父应用必须重新安装子应用来重新构建或部署。 <br />2.中等难度搭建。 |                                                              |
| 搭建难度     | 简单                                                         | 中等                                                         | 困难                                                         |
| 代码是否独立 | No                                                           | No                                                           | ✅                                                            |
| 分开构建     | No                                                           | ✅                                                            | ✅                                                            |
| 分别部署     | No                                                           | ✅                                                            | ✅                                                            |
| 例子         | [simple-webpack-example](https://github.com/joeldenning/simple-single-spa-webpack-example)[single-spa-examples](https://github.com/single-spa/single-spa-examples) | [single-spa-login-example-with-npm-packages](https://github.com/jualoppaz/single-spa-login-example-with-npm-packages) | [SystemJS example](https://gitlab.com/TheMcMurder/single-spa-portal-example) |





### 基础示例

以下示例使用 single-spa 接入 a、 b 两个子应用，当路由匹配到应用时，触发应用对应生命周期。

```html
<head>
	<meta charset="UTF-8">
    <meta http-equiv="'X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="https://cdn.bootcdn.net/ajax/libs/single-spa/5.9.3/umd/single-spa.min.js"></script>
	<div id="app"></div>
<script>
// 微前端 就是可以加载不同的应用 基于路由的微前端
//如何接入已经写好的应用 对于singlespa而言，我们需要改写子应用(接入协议)bootstrap,mount,unmo
const { registerApplication,start }= singleSpalet

// a 应用接入协议
app1={
    // 启动 a 应用 bootstrap生命周期，当路由匹配到 a 应用时候触发，二次匹配成功不触发该声明周期
	bootstrap:[
		async()=> console.log('app1 bootstrap1'),
        async()=> console.log('appl bootstrap2')
    ],
    // a 应用挂载时候触发
	mount:[
        async(props)=> {
            console.log('接收基础传入的参数',props)
            // new Vue().$mount()
            app1.innerHTML = 'APP1'
            
        },
        async(props)=> {
            console.log('接收基础传入的参数',props)
            // new Vue().$mount()
            console.log('app1 mount2')
        }
    ],
    // a 应用卸载时候触发
    unmount:async()=>{
        console.log('app1 unmount')
    }
}
// b 应用接入协议  
app2={
	bootstrap:[
		async()=> console.log('app2 bootstrap1'),
        async()=> console.log('app2 bootstrap2')
    ],
	mount:[
        async()=> {
            // new Vue().$mount()
            app2.innerHTML = 'APP2'
        },
        async()=> {
            // new Vue().$mount()
            console.log('app2 mount2')
        }
    ],
    unmount:async()=>{
        console.log('app2unmount')
     }
}
    
    
    
//注册 a 应用，根据路径加载应用。当路径是#/a 的时候就加载 a 应用,并传入参数 {a:1}
registerApplication('a',async()=> app1location =>location.hash.startsWith('#/a'),{ a:1 })
// 注册 b 应用，当路径是#/b 的时候就加载 b 应用
registerApplication('b',async()=> app2,location =>location.hash.startsWith('#/b'),{ a:2 })

// 开启路径监控，路径切换时候调用mount和unmount
start()
</script>
```

### 应用状态

single-spa 应用状态流程如下：

<img src="../images/image-20240527193955605.png" style="zoom:67%;" />

single-spa 应用的加载状态流程的详细说明：

1. **未加载状态 (Not Loaded)**
   - 应用尚未加载。这是应用的初始状态，表示应用还未被 single-spa 加载或注册。
2. **加载资源 (LOADING SOURCE CODE)**
   - 应用的资源（如 JavaScript、CSS 文件）正在被加载。single-spa 会异步加载应用的资源文件。
3. **资源加载失败 (LOADERR)**
   - 加载应用资源时发生错误。可能是网络问题、文件不存在或其他原因导致资源加载失败。
4. **代码出错 (SKIP BECAUSE BROKEN)**
   - 加载的资源中存在错误，导致应用无法启动。例如，JavaScript 代码有语法错误。
5. **没有启动 (NOT BOOTSTRAPPED)**
   - 应用的资源已加载，但尚未启动。这可能是因为应用正在等待某些条件满足后才开始启动。
6. **启动中 (BOOTSTRAPPING)**
   - 应用正在启动。这通常涉及到执行应用的启动逻辑，如初始化组件、路由等。
7. **没有挂载 (NOT MOUNTED)**
   - 应用已启动，但尚未挂载到 DOM 上。在 single-spa 中，启动和挂载是两个不同的步骤。
8. **挂载完成 (MOUNTED)**
   - 应用已成功挂载到 DOM 上，现在可以在浏览器中看到应用的内容。
9. **卸载 (UNMOUNTED)**
   - 应用已从 DOM 上卸载，但实例仍然存在。这通常发生在应用路由变化或应用被显式卸载时。
10. **ONMOUNTING**
    - 应用正在被挂载到 DOM 上。这是一个挂载过程中的状态，表示应用即将成为可见状态。
11. **更新 (UPDATING)**
    - 应用正在更新。这可能发生在应用的配置或资源发生变化时。
12. **移除加载 (ONLOADING)**
    - 应用正在被 single-spa 加载。这是一个通用的状态，表示应用正在被 single-spa 处理。
13. **挂载超时 (NOT MOUNTED IN TIME)**
    - 应用在规定的时间内没有完成挂载。这可能是由于应用启动逻辑中的性能问题或其他原因。
14. **启动超时 (TIMEOUT)**
    - 应用在规定的时间内没有完成启动。这可能需要开发者检查应用的启动代码是否存在阻塞操作。

这些状态提供了 single-spa 应用在加载和运行过程中的详细视图，帮助开发者了解应用的当前阶段，并在出现问题时进行调试。开发者可以利用这些状态来实现更复杂的应用逻辑，例如，根据应用的状态来调整路由行为或执行特定的操作。





### 接入应用

Single-spa 框架为每个小应用定义了生命周期钩子，包括 `bootstrap`、`mount`、`update` 和 `unmount`。

single-spa 接入应用，需要改写子应用（接入协议）：`bootstrap`、`mount`、`update` 和 `unmount`。







---



## [**qiankun**](https://qiankun.umijs.org/zh/guide)

[Qiankun](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun) 是一个基于 [single-spa](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCanopyTax%2Fsingle-spa) ，阿里系开源的微前端框架，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。

**设计理念：**

- 由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。
- 同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入 像使用 iframe 一样简单。
- 微前端的核心目标是 将巨石应用 拆解成若干可以 自治的松耦合微应用 ，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。



**优点：**

- 📦 **基于 [single-spa](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCanopyTax%2Fsingle-spa)** 封装，提供了更加开箱即用的 API。
- 📱 **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
- 💪 **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单。
- 🛡 **样式隔离**，确保微应用之间样式互相不干扰。
- 🧳 **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突。
- ⚡️ **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
- 🔌 **umi 插件**，提供了 [@umijs/plugin-qiankun](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fplugin-qiankun) 供 umi 应用一键切换成微前端架构系统。
- 🔥 **社区较为活跃**，维护者也较多，有问题会及时得到响应；

**缺点：**

- 可能对一些 jQuery 老项目支持性不是特别好；
- 安全和性能可能会有影响，具体取决于项目；
- 对 eval 的争议，`eval`函数的安全和性能是有一些争议的：[MDN的eval介绍](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Feval)；

> 另外阿里系还有另外两款微前端框架：
>
> - [Icestark](https://link.juejin.cn?target=https%3A%2F%2Ficestark.gitee.io%2F)，是一个面向大型系统的微前端解决方案；
> - [Alibaba Cloud Alfa](https://link.juejin.cn?target=https%3A%2F%2Falfajs.io%2Fdocs%2Fintro.html)，是在阿里云控制台体系中孵化的微前端方案，定位是面向企业级的微前端体系化解决方案；
>
> 这两款框架相较于 `Qiankun` 来讲社区活跃度以及 demo 较少，所以不太推荐使用该框架，大家了解即可。

 

## [**MicroApp**](https://micro-zoe.github.io/micro-app/)

[Micro App](https://link.juejin.cn?target=https%3A%2F%2Fmicro-zoe.github.io%2Fmicro-app%2F) 是京东出的一款基于 `Web Component` 原生组件进行渲染的微前端框架，不同于目前流行的开源框架，它从组件化的思维实现微前端，旨在降低上手难度、提升工作效率。

它是目前市面上接入微前端成本最低的框架，并且提供了 JS沙箱、样式隔离、元素隔离、预加载、资源地址补全、插件系统、数据通信 等一系列完善的功能。

**优点：**

- 简单：只需一行代码，实现微前端，如此简单；
- 无关技术栈：任何框架皆可使用；
- 静态资源补全；
- JS沙箱；
- 样式隔离；
- Qiankun 微前端框架的优势他都有；

 

## [**无界**](https://wujie-micro.github.io/doc/)



## [**EMP**](https://emp2.netlify.app/)

[EMP](https://link.juejin.cn?target=https%3A%2F%2Femp2.netlify.app%2F) 是欢聚时代基于 `Webpack5 Module Federation` 搭建的微前端方案；

由于是基于 `Webpack5 Module Federation` 来搭建的，所以相对与微前端跨框架、状态解决方案混淆比较严重，且 EMP 解决的是项目解耦而不是多系统聚合，与 bit（下面讲的） 这种跨项目组件复用平台较为类似；

**优点：**

- 依赖自动管理，可以共享 Host 中的依赖，版本不满足要求时自动 fallback 到 Remote 中依赖；
- 共享模块粒度自由掌控，小到一个单独组件，大到一个完整应用。既实现了组件级别的复用，又实现了微服务的基本功能；
- 共享模块非常灵活，模块中所有组件都可以通过异步加载调用；

**缺点：**

- 无法做到多框架兼容等微前端方案的痛点；
- 基于 **Webpack5 Module Federation**，需要统一 Webpack5 技术；
- 文档资料，社区不够活跃；

 

## [Garfish](https://www.garfishjs.org/guide/)

[Garfish](https://link.juejin.cn?target=https%3A%2F%2Fwww.garfishjs.org%2F) 是由字节跳动开源的一套微前端解决方案，主要用于解决现代 web 应用在前端生态繁荣和 web 应用日益复杂化两大背景下带来的 `跨团队协作、技术体系多样化、应用日益复杂化`等问题，Garfish 已经经过大量的线上应用的打磨和测试，功能稳定可靠。

**框架特性：**

- 🌈 **丰富高效的产品特征**
  - Garfish 微前端子应用支持任意多种框架、技术体系接入
  - Garfish 微前端子应用支持「**独立开发**」、「**独立测试**」、「**独立部署**」
  - 强大的预加载能力，自动记录用户应用加载习惯增加加载权重，应用切换时间极大缩短
  - 支持依赖共享，极大程度的降低整体的包体积，减少依赖的重复加载
  - 内置数据收集，有效的感知到应用在运行期间的状态
  - 支持多实例能力，可在页面中同时运行多个子应用提升了业务的拆分力度
- 📦 **高扩展性的核心模块**
  - 通过 Loader 核心模块支持 HTML entry、JS entry 的支持，接入微前端应用简单易用
  - Router 模块提供了路由驱动、主子路由隔离，用户仅需要配置路由表应用即可完成自主的渲染和销毁，无需关心内部逻辑
  - Sandbox 模块为应用的 Runtime 提供运行时隔离能力，能有效隔离 JS、Style 对应用的副作用影响
  - Store 提供了一套简单的通信数据交换机制
- 🎯 **高度可扩展的插件机制**
  - 提供业务插件满足各种定制需求



## 框架选型

适合后台管理系统且都是最新的 MV* 框架：

*  Qiankun
* Micro App
* Garfish



适合需要聚合某些老旧框架（jQuery）的项目：

* Qiankun
* MicroApp（优先考虑 ）



适合 SEO 的微前端项目

*  Piral
* PuzzleJs

 