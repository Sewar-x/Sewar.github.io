# 树

![image-20231022171502467](../images/数据结构-树.png)

## 树结构

不同于我们上面介绍的线性结构，树是一种非线性结构。

图：

![图片](../images/tree.png)

它遵循：

- 仅有唯一一个根节点，没有节点则为空树
- 除根节点外，每个节点都有并仅有唯一一个父节点
- 节点间不能形成闭环

这就是树！

树有几个概念：

- 拥有相同父节点的节点，互称为兄弟节点
- **节点的深度** ：从根节点到该节点所经历的边的个数
- **节点的高度** ：节点到叶节点的最长路径
- 树的高度：根节点的高度

![图片](../images/tree2.png)

B、C、D就互称为兄弟节点，其中，节点B的高度为2，节点B的深度为 1，树的高度为3

#### 高度

树的高度计算公式：

![图片](../images/二叉树-树高度计算.png)

下图每个节点值都代表来当前节点的高度：

![图片](../images/tree3.png)

## 二叉树

二叉树，故名思义，最多仅有两个子节点的树（最多能分两个叉的树🤦‍♀️）：

图：

![图片](../images/tree4.png)

## 平衡二叉树

二叉树中，每一个节点的左右子树的高度相差不能大于 1，称为平衡二叉树。

![图片](../images/tree6.png)

另外还有满二叉树、完全二叉树等：

- **满二叉树**：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树
- **完全二叉树**：深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边

## 在代码中如何去表示一棵二叉树

### 链式存储法

二叉树的存储很简单，在二叉树中，我们看到每个节点都包含三部分：

- 当前节点的 val
- 左子节点 left
- 右子节点 right

所以我们可以将每个节点定义为：

```js
function Node(val) {
    // 保存当前节点 key 值
    this.val = val
    // 指向左子节点
    this.left = null
    // 指向右子节点
    this.right = null
}
```

一棵二叉树可以由根节点通过左右指针连接起来形成一个树。

```js
function BinaryTree() {
  let Node = function (val) {
    this.val = val
    this.left = null
    this.right = null
  }
  let root = null
}
```

### 数组存储法（适用于完全二叉树）

下图就是一棵完全二叉树，

如果我们把根节点存放在位置 `i=1` 的位置，则它的左子节点位置为 `2i = 2` ，右子节点位置为 `2i+1 = 3` 。

如果我们选取 B 节点 `i=2` ，则它父节点为 `i/2 = 1` ，左子节点 `2i=4` ，右子节点  `2i+1=5` 。

以此类推，我们发现所有的节点都满足这三种关系：

- 位置为 i 的节点，它的父节点位置为 `i/2`
- 它的左子节点 `2i`
- 它的右子节点  `2i+1`

因此，如果我们把完全二叉树存储在数组里（从下标为 1 开始存储），我们完全可以通过下标找到任意节点的父子节点。从而完整的构建出这个完全二叉树。这就是数组存储法。

数组存储法相对于链式存储法不需要为每个节点创建它的左右指针，更为节省内存。

![图片](../images/完全二叉树.png)

## 二叉树的遍历

二叉树的遍历可分为：

- 前序遍历
- 中序遍历
- 后序遍历

所谓前、中、后，不过是根的顺序，即也可以称为先根遍历、中根遍历、后根遍历

#### 前序遍历

对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树

![图片](../images/前序遍历.png)

#### 中序遍历

对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树

![图片](../images/中序遍历.png)

#### 后序遍历

对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点

![图片](../images/后序遍历.png)



#### 前序遍历实现

>  遍历二叉树的过程也就是一个递归的过程，例如前序遍历，先遍历根节点，然后是根的左子树，最后右子树；遍历根节点的左子树的时候，又是先遍历左子树的根节点，然后左子树的左子树，左子树的右子树…….

##### 递归实现

```js
// 前序遍历
const preorderTraversal = (root) => {
    let result = []
    var preOrderTraverseNode = (node) => {
        if(node) {
            // 先根节点
            result.push(node.val)
            // 然后遍历左子树
            preOrderTraverseNode(node.left)
            // 再遍历右子树
            preOrderTraverseNode(node.right)
        }
    }
    preOrderTraverseNode(root)
    return result
};
```

##### 迭代实现

>  利用栈来记录遍历的过程，实际上，递归就使用了调用栈，所以这里我们可以使用栈来模拟递归的过程
>
> - 首先根入栈
> - 将根节点出栈，将根节点值放入结果数组中
> - 然后遍历左子树、右子树，因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈
> - 继续出栈（左子树被出栈）…….
>
> 依次循环出栈遍历入栈，直到栈为空，遍历完成

```js
// 前序遍历
const preorderTraversal = (root) => {
    const list = [];
    const stack = [];
    
    // 当根节点不为空的时候，将根节点入栈
    if(root) stack.push(root)
    while(stack.length > 0) {
        const curNode = stack.pop()
        // 第一步的时候，先访问的是根节点
        list.push(curNode.val)
        
        // 我们先打印左子树，然后右子树
        // 所以先加入栈的是右子树，然后左子树
        if(curNode.right !== null) {
            stack.push(curNode.right)
        }
        if(curNode.left !== null) {
            stack.push(curNode.left)
        }
    }
    return list
}
```

> ##### 复杂度分析：
>
> 空间复杂度：O(n)
>
> 时间复杂度：O(n)



#### 中序遍历

> * 遍历左子树
> * 遍历当前节点
> * 遍历右子树

##### 递归实现

````js
// 中序遍历
const indorderTraversal = (root) => {
    let result = []
    var indOrderTraverseNode = (node) => {
        if(node) {
             // 遍历左子树
            indOrderTraverseNode(node.left)
            // 根节点
            result.push(node.val)
            // 再遍历右子树
            indOrderTraverseNode(node.right)
        }
    }
    indorderTraversal(root)
    return result
};
````

##### 迭代实现

> * 将当前节点指针指向根节点，循环当前节点不为空或栈不为空
>   * 循环找查找左子树，并将左子树入栈，直到左子树为空
>   * 栈顶元素出栈，访问当前节点
>   * 将当前节点右子树入栈

```js
const inorderTraversal = (root) => {
  const result = [];
  const stack = [];

  let current = root;

  while (current || stack.length > 0) {
    // 将左子树的所有左节点入栈
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // 弹出栈顶节点，并将其值加入结果数组
    current = stack.pop();
    result.push(current.val);

    // 处理右子树
    current = current.right;
  }

  return result;
};
```



#### 后序遍历

> * 遍历左子树
> * 遍历右子树
> * 遍历当前节点

##### 递归实现

```js
var postOrderTraversal = (root)=> {
	let result = [];
    var postOderTraverNode = (node)=> {
        if(node) {
            // 遍历左子树
            postOderTraverNode(node.left);
            // 遍历右子树
            postOderTraverNode(node.right);
            // 遍历当前节点
            result.push(node.value)
        }
    }
    postOderTraverNode(root); 
    return result;
}
```



##### 迭代实现

> * 将当前节点指针指向根节点，循环当前节点不为空或栈不为空
>   * 循环查找左子树，并将左子树入栈，直到左子树为空
>   * 访问当前节点栈顶元素
>   * 如果`current`的右子树为空或者已经遍历过右子树（通过变量`prev`进行判断），则将`current`的值加入结果数组`result`，将`current`出栈，将`prev`更新为`root`，并将`root`设为`null`，以便继续处理栈中的下一个节点。
>   * 如果`current`的右子树不为空且还未遍历过右子树，则将`current`的右子树赋值给`current`，继续遍历右子树。

```js
const postorderTraversal = (root) => {
  const result = [];
  const stack = [];

  let current = root;
  let prev = null;
  while (current || stack.length > 0) {
    // 将左子树的所有左节点入栈
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // 获取栈顶元素
    current = stack[stack.length-1]
     // 如果右子树为空或已经遍历过右子树
    if(!current.right || prev === current) {   
      result.push(current.val); // 将当前节点值加入结果数组
      stack.pop(); // 将当前节点出栈
      prev = current; // 记录上一个已遍历的节点
      current = null; // 继续遍历栈中的下一个节点
    }else {
        // 处理右子树
    	current = current.right;
    }
  }

  return result;
};
```



#### 层次遍历

给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：给定二叉树 `[3,9,20,null,null,15,7]` ,

```js
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```js
[
  [15,7],
  [9,20],
  [3]
]
```

##### 解法一：BFS（广度优先遍历）

> BFS 是按层层推进的方式，遍历每一层的节点。题目要求的是返回每一层的节点值，所以这题用 BFS 来做非常合适。BFS 需要用队列作为辅助结构，我们先将根节点放到队列中，然后不断遍历队列。
>
> * 使用两个队列存储：
>   * 当前遍历数据队列 `queue`：保存当前遍历的数据
>   * 下一层数据队列 `tempQueue`: 保存节点的子节点
> * 根节点入队列，循环遍历当前数据队列 queue:
>   * 节点出队列，访问节点，将节点左右子节点入  `tempQueue`；
>   * 替换当前 `queue` 为 `tempQueue`；

```js
const levelOrderBottom = function(root) {
    if(!root) return []
    let res = [], 
        queue = [root] 
    while(queue.length) {
        let curr = [], // 每层数组
            tempQueue = [] // 临时队列，存储 queue 下一层数据的队列
        while(queue.length) {
            let node = queue.shift()
            curr.push(node.val)
            if(node.left) tempQueue.push(node.left)
            if(node.right) tempQueue.push(node.right)
        }
        res.push(curr)
        queue = tempQueue // 将当前队列替换为下一层数据的临时队列
    }
    return res.reverse()
};
```

> **复杂度分析**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)

##### 解法二：DFS（深度优先遍历）

>  DFS 是沿着树的深度遍历树的节点，尽可能深地搜索树的分支
>
> DFS 做本题的主要问题是：DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 `depth` 。递归到新节点要把该节点放入 `depth` 对应列表的末尾。
>
> 当遍历到一个新的深度 `depth` ，而最终结果 `res` 中还没有创建 `depth` 对应的列表时，应该在 `res` 中新建一个列表用来保存该 `depth` 的所有节点。



```js
const levelOrderBottom = function(root) {
    const res = []
    var dep = function (node, depth){
        if(!node) return
        res[depth] = res[depth]||[]
        res[depth].push(node.val)
        dep(node.left, depth + 1)
        dep(node.right, depth + 1)
    }
    dep(root, 0)
    return res.reverse()   
};
```

> **复杂度分析：**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(h)，h为树的高度

#### 层序遍历

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。（即逐层地，从左到右访问所有节点）。

**示例：**二叉树：`[3,9,20,null,null,15,7]` ,

```js
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```js
[
  [3],
  [9,20],
  [15,7]
]
```



这道题和二叉树的层次遍历相似，只需要把 `reverse()` 去除就可以了

##### **BFS 广度优先遍历**

```js
const levelOrder = function(root) {
    if(!root) return []
    let res = [], 
        queue = [root]
    while(queue.length) {
        let curr = [],
            temp = []
        while(queue.length) {
            let node = queue.shift()
            curr.push(node.val)
            if(node.left) temp.push(node.left)
            if(node.right) temp.push(node.right)
        }
        res.push(curr)
        queue = temp
    }
    return res
};
```

##### **DFS 深度优先遍历**

```js
const levelOrder = function(root) {
    const res = []
    var dep = function (node, depth){
        if(!node) return
        res[depth] = res[depth]||[]
        res[depth].push(node.val)
        dep(node.left, depth + 1)
        dep(node.right, depth + 1)
    }
    dep(root, 0)
    return res
}; 
```





### 重构二叉树：从前序与中序遍历序列构造二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

**注意:**你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```js
    3
   / \
  9  20
    /  \
   15   7
```

**限制：**

```
0 <= 节点个数 <= 5000
```

* 解题思路：

  >  仔细分析前序遍历和中序遍历可以知道（以题目为例）：
  >
  > 1. 前序遍历的第一个元素一定是根节点，这里是`3`
  > 2. 找到根节点之后，根节点在中序遍历中把数组一分为二，即两个数组`[9]`和`[15, 20, 7]`，这两个数组分别是根节点`3`的左子树和右子树的中序遍历。
  > 3. 前序遍历数组去掉根节点之后是`[9,20,15,7]`，而这个数组的第1项`[9]`（左子树的大小）和后3项`[20, 15, 7]`（右子树的大小）又分别是左子树和右子树的前序遍历 到这里已经很明显了，用递归

  ```js
  function TreeNode(val) {
      this.val   =  val;
      this.left  =  null;
      this.right =  null;
  }
  const buildTree = function (preorder, inorder) {
      if (preorder.length) {
          let head = new TreeNode(preorder.shift());
          let index = inorder.indexOf(head.val);
          head.left = buildTree(
              preorder.slice(0, index),
              inorder.slice(0, index)
          );
          head.right = buildTree(preorder.slice(index), inorder.slice(index + 1));
          // 这里要注意，preorder前面shift一次长度比inorder小1
          return head;
      } else {
          return null;
      }
  };
  ```
  
  



###  二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**给定二叉树 `[3,9,20,null,null,15,7]` ，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3



**解法一：递归**

> * 使用递归深度遍历左子树的高度和右子树深度
> * 比较左子树和右子树深度，获取最大深度
> * 返回最大深度加1；

```js
const maxDepth = function(root) {
    if(!root) return 0 
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))
};
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(log⁡n)

**解法二：非递归，层次遍历获取层数（广度优先搜索）**

> 二叉树层次即为二叉树最大深度，使用层序遍历（广度优先搜索）的方式：
>
> * 使用队列存储每一层节点；
> * 获取每一层的节点数（队列长度即为节点数）；
> * 遍历每一层的节点，将节点的左子树和右子树入队列；
> * 遍历完成一层，树深度加1；

```js
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

function maxDepth(root) {
  if (root === null) {
    return 0;
  }

  let depth = 0;
  const queue = [root]; //队列存储每一层节点

  while (queue.length > 0) {
    // 获取每一层的节点数（队列长度即为节点数）
    const levelSize = queue.length;
	// 遍历每一层的节点，将节点的左子树和右子树入队列
    for (let i = 0; i < levelSize; i++) {
      const current = queue.shift();

      if (current.left !== null) {
        queue.push(current.left);
      }

      if (current.right !== null) {
        queue.push(current.right);
      }
    }
	// 遍历完成一层，树深度加1
    depth++;
  }

  return depth;
}

// 示例用法
// 创建二叉树
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);

const result = maxDepth(root);
console.log(result); // 输出: 3
```



**解法三：非递归，深度优先搜索**

> 先序遍历（深度优先搜索）子树，并使用 maxDep 记录最大深度
>
> * 使用栈保存遍历的节点；
> * 循环遍历栈，直到栈为空；
> * 深度遍历左子树，将左子树入栈，深度加一，并比较当前深度是否为最大深度，如果是，保存最大深度；
> * 出栈，深度减一，指针指向右子树

```js
const maxDepth = (root) => {
  if (!root) return 0;
  let stack = [];
  let cur = root;
  let dep = 0, maxDep = 0; // 修正初始值为0
  stack.push(root);
  while (stack.length) {
    while (cur) { // 深度遍历左子树
      dep++; //深度加1
      if (dep > maxDep) { // 更新maxDep
        maxDep = dep;
      }
      stack.push(cur.left);
      cur = cur.left;
    }
    cur = stack.pop(); // 出栈遍历节点右节点
    dep--; //出栈后深度减1
    cur = cur.right; // 遍历节点右节点
  }
  return maxDep;
};
```



### 二叉树最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 `[3,9,20,null,null,15,7]`,

```js
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度 2



**解法一：递归**

> 深度优先 + 分治
>
> - 左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1
> - 左树为空：右子树最小深度的最小值 + 1
> - 右树为空：左子树最小深度 + 1

```js
    var minDepth = function (root) {
      if (!root) {
        return 0;
      }
      if (!root.left) {
        return 1 + minDepth(root.right);
      }
      if (!root.right) {
        return 1 + minDepth(root.left);
      }
      return Math.min(minDepth(root.left), minDepth(root.right)) + 1
    };

```



## 二叉查找树（BST树）

* 二叉查找树木又称二叉搜索树

* 二叉搜索树上的每个节点都需要满足：

  - 左子节点值小于该节点值

  - 右子节点值大于等于该节点值


![图片](../images/二叉树查找.png)

在二叉树中，所有子节点值都是没有固定规律的，所以使用二叉树存储结构存储数据时，查找数据的时间复杂度为 O(n)，因为它要查找每一个节点。

而使用二叉查找树就不同了，例如上图，我们如果要查找 6 ，先从根节点 10 比较，6 比 10 小，则查找左子树，再与 8 比较，6 比 8 小，继续查找 8 的左子树，也就是 6，我们找到了元素，结束。







### 基本操作

```js
function BinarySearchTree() {
  let Node = function (key) {
    this.key = key
    this.left = null
    this.right = null
  }
  let root = null
  
  // 插入
  this.insert = function(key){}
  
  // 查找
  this.search = function(key){}
  
  // 删除
  this.remove = function(key){}
  
  // 最大值
  this.max = function(){}
  
  // 最小值
  this.min = function(){}
  
  // 中序遍历
  this.inOrderTraverse = function(){}
  
  // 先序遍历
  this.preOrderTraverse = function(){}
  
  // 后序遍历
  this.postOrderTraverse = function(){}
}
```

**插入：**

- 首先创建一个新节点
- 判断树是否为空，为空则设置插入的节点为根节点，插入成功，返回
- 如果不为空，则比较该节点与根结点，比根小，插入左子树，否则插入右子树

```js
function insert(key) {
  // 创建新节点
  let newNode = new Node(key)
  // 判断是否为空树
  if(root === null) {
    root = newNode
  } else {
    insertNode(root, newNode)
  }
}

// 将 insertNode 插入到 node 子树上
function insertNode(node, newNode) {
  if(newNode.key < node.key) {
    // 插入 node 左子树
    if(node.left === null) {
      node.left = newNode
    } else {
      insertNode(node.left, newNode)
    }
  } else {
    // 插入 node 右子树
    if(node.right === null) {
      node.right = newNode
    } else {
      insertNode(node.right, newNode)
    }
  }
}
```

**最值：**

最小值：树最左端的节点

最大值：树最右端的节点

```js
// 最小值
function min() {
  let node = root
  if(node) {
    while(node && node.left !== null) {
      node = node.left
    }
    return node.key
  }
  return null
}

// 最大值
function max() {
  let node = root
  if(node) {
    while(node && node.right !== null) {
      node = node.right
    }
    return node.key
  }
  return null
}
```

**查找：**

```js
function search(key) {
  return searchNode(root, key)
}

function searchNode(node, key) {
  if(node === null) 
    return false
  if(key < node.key) {
    return searchNode(node.left, key)
  } else if(key > node.key) {
    return searchNode(node.right, key)
  } else {
    return true
  }
}
```

**删除：**

* 二叉查找树（Binary Search Tree，BST）的删除节点操作可以分为三种情况：
  1. 删除的节点是叶子节点（没有子节点）：直接删除即可。
  
     > * 示例：删除元素 27
     >
     > ![img](../images/二叉查找树-删除.gif)
  
  2. 删除的节点有一个子节点：将子节点替代要删除的节点。
  
     > * 示例：删除元素 50
     >
     > ![img](../images/二叉查找树-删除1.gif)
  
  3. 删除的节点有两个子节点：需要找到该节点的后继节点或前驱节点来替代要删除的节点。
  
     > * 前驱节点与后继节点：
     >
     >   * 该节点的后继节点：排在该节点值的下一个位置的节点，在该节点右子树的最小节点（上图中 20 的后继节点是29）
     >   * 该节点的前驱节点：排在该节点值的上一个位置的节点，在该节点左子树的最大节点（上图中 20 的前驱节点是13）
     >
     > * 使用后继节点代替删除节点，需要考虑两种情况：
     >
     >   * 后继节点没有子节点：直接使用后继节点代替当前节点，后删除后继节点；
     >
     >     ![图一](../images/二叉查找树-删除2.gif)
     >
     >   * 后继节点有子节点：使用后继节点代替当前节点后，将后继节点的子节点代替后继节点
     >
     >     ![图二](../images/二叉查找树-删除3.gif)
     >
     > 

```js
function remove(key) {
  root = removeNode(root, key)
}

function removeNode(node, key) {
  if(node === null) 
    return null
  if(key < node.key) {
    return removeNode(node.left, key)
  } else if(key > node.key) {
    return removeNode(node.right, key)
  } else {
    // key = node.key 删除
    //叶子节点
    if(node.left === null && node.right === null) {
      node = null
      return node
    }
    // 只有一个子节点
    if(node.left === null) {
      node = node.right
      return node
    }
    if(node.right === null) {
      node = node.left
      return node
    }
    // 有两个子节点
    // 获取前驱节点替代当前节点：右子树的最小值替换当前节点
    let minRight = findMinNode(node.right)
    node.key = minRight.key
    node.right = removeNode(node.right, minRight.key)
    return node
  }
}

// 获取 node 树最小节点
function findMinNode(node) {
  if(node) {
    while(node && node.right !== null) {
      node = node.right
    }
    return node
  }
  return null
}
```

### 遍历

**中序遍历：**

> 中序遍历就是把根放在中间的遍历，即按先左节点、然后根节点、最后右节点（左根右）的遍历方式。
>
> 由于BST树任意节点都大于左子节点值小于等于右子节点值的特性，所以 **中序遍历其实是对🌲进行排序操作** ，并且是按从小到大的顺序排序。
>
> ![image-20231118102533992](../images/二叉搜索树-中序遍历.png)



```js
function inOrderTraverse(callback) {
  inOrderTraverseNode(root, callback)
}

function inOrderTraverseNode(node, callback) {
  if(node !== null) {
    // 先遍历左子树
    inOrderTraverseNode(node.left, callback)
    // 然后根节点
    callback(node.key)
    // 再遍历右子树
    inOrderTraverseNode(node.right, callback)
  }
}

// callback 每次将遍历到的结果打印到控制台
function callback(key) {
  console.log(key)
}
```

**先序遍历：**

>  已经实现的中序遍历，先序遍历就很简单了，它是按根左右的顺序遍历

```js
function preOrderTraverse() {
  preOrderTraverseNode(root, callback)
}

function preOrderTraverseNode(node, callback) {
  if(node !== null) {
    // 先根节点
    callback(node.key)
    // 然后遍历左子树
    preOrderTraverseNode(node.left, callback)
    // 再遍历右子树
    preOrderTraverseNode(node.right, callback)
  }
}

// callback 每次将遍历到的结果打印到控制台
function callback(key) {
  console.log(key)
}
```

**后序遍历：**

> 后序遍历按照左右根的顺序遍历，实现也很简单。

```js
function postOrderTraverse() {
  postOrderTraverseNode(root, callback)
}

function postOrderTraverseNode(node, callback) {
  if(node !== null) {
    // 先遍历左子树
    postOrderTraverseNode(node.left, callback)
    // 然后遍历右子树
    postOrderTraverseNode(node.right, callback)
    // 最后根节点
    callback(node.key)
  }
}

// callback 每次将遍历到的结果打印到控制台
function callback(key) {
  console.log(key)
}
```



### [**判断是否为二叉搜索树**](https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。

二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。

> 例1：
>
> ![img](../images/二叉搜索树1.png)
>
> 输入：
>
> ```
> {1,2,3}
> ```
>
> 返回值：false
>
> ![img](../images/二叉搜索树2.png)
>
> 输入：
>
> ```
> {2,1,3}
> ```
>
> 返回值：true

**思路：**

>  二叉搜索树的特性就是中序遍历是递增序。
>
>  既然是判断是否是二叉搜索树，那我们可以使用中序递归遍历。
>
>  只要之前的节点是二叉树搜索树，那么如果当前的节点小于上一个节点值那么就可以向下判断。

**递归:中序遍历**

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return bool布尔型
 */
function isValidBST( root ) {
    // write code here
    let preVal = Math.Infinity; //保存上一个遍历节点的值
    if(root == null) return true;
    if(!isValidBST(root.left)) return false; //递归遍历左子树，判断左子树
    if(root.val < preVal) return false; //中序遍历中当前节点是小于先序节点的值，则不是搜索二叉树
    preVal =  root.val; //记录当前节点的值
    return isValidBST(root.right);
}
module.exports = {
    isValidBST : isValidBST
};
```



### BST树的局限

* 二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。

* 在理想情况下，二叉树每多一层，可以存储的元素都增加一倍。也就是说 n 个元素的二叉搜索树，对应的树高为 O(logn)。所以我们查找元素、插入元素的时间也为 O(logn)。

* 但在实际应用中，并不是那么理想，例如一直递增或递减的给一个二叉查找树插入数据，那么所有插入的元素就会一直出现在一个树的左节点上，数型结构就会退化为链表结构，时间复杂度就会趋于 O(n)![image-20231119115742908](../images/二叉查找树-退化成单链表.png)

而我们上面的平衡树就可以很好的解决这个问题，所以平衡二叉查找树由此诞生。

## 平衡二叉查找树（AVL树）

概念：左右子树高度差不大于 1， 任意节点值大于它的左子节点值，小于等于它的右子节点值。

特点：

* **高度平衡**：平衡二叉树的左右子树的高度差不超过1，这意味着树的高度相对较低，使得查找、插入和删除等操作的时间复杂度可以在较低的范围内保持平衡。
* **快速查找**：由于平衡二叉树的结构特点，可以通过比较根节点的值与目标值的大小来确定向左子树或右子树进行查找，从而在平均情况下实现快速的查找操作。
* **平衡性维护**：平衡二叉树在插入或删除节点时会自动进行平衡调整，通过旋转操作可以保持树的平衡性，避免出现极端情况下树的高度过大或过小，导致查找性能下降。
* **操作复杂度保持较低**：在平衡二叉树中，插入、删除和查找等操作的平均时间复杂度为O(log n)，其中n是树中节点的数量。这使得平衡二叉树在处理大量数据时具有较高的效率。

![图片](../images/avl树.png)



#### 平衡因子

**定义：**某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高

![image-20231119120102497](../images/平衡二叉树-平衡因子.png)![image-20231119120112702](../images/平衡二叉树-平衡因子1.png)![image-20231119120120522](../images/平衡二叉树-平衡因子2.png)

#### 创建平衡二叉树

思路：

1. 定义平衡二叉树节点的结构：节点应包含值、左子树和右子树的引用。
2. 实现**计算节点高度的函数**：编写一个函数来计算节点的高度，即以该节点为根的子树的高度。节点的高度可以定义为左子树和右子树中较高的那个子树的高度加1。
3. 实现**平衡因子计算函数**：平衡因子是指左子树高度与右子树高度之间的差值。编写一个函数来计算平衡因子，即左子树高度减去右子树高度。
4. 实现**节点旋转操作**：平衡二叉树通过旋转操作来保持平衡。根据情况，可能需要进行左旋、右旋或双旋转。这些旋转操作可以通过调整节点的指针来实现。
5. 实现**插入节点操作**：编写一个函数来插入新节点到平衡二叉树中。首先，按照二叉查找树的规则找到插入位置。然后，通过旋转操作来调整树的平衡性。

```js
// 定义平衡二叉树节点
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// 计算节点高度
function getHeight(node) {
  if (node === null) {
    return -1;
  }
  return Math.max(getHeight(node.left), getHeight(node.right)) + 1;
}

// 计算平衡因子
function getBalanceFactor(node) {
  return getHeight(node.left) - getHeight(node.right);
}

// 左旋转操作
function rotateLeft(node) {
  const newRoot = node.right;
  node.right = newRoot.left;
  newRoot.left = node;
  return newRoot;
}

// 右旋转操作
function rotateRight(node) {
  const newRoot = node.left;
  node.left = newRoot.right;
  newRoot.right = node;
  return newRoot;
}

// 插入节点
function insertNode(root, value) {
  if (root === null) {
    return new TreeNode(value);
  }

  if (value < root.value) {
    root.left = insertNode(root.left, value);
  } else if (value > root.value) {
    root.right = insertNode(root.right, value);
  } else {
    // 值已存在，不进行插入
    return root;
  }
  // 计算平衡因子
  const balanceFactor = getBalanceFactor(root);

  // 左子树的左侧插入情况，需要进行右旋转
  if (balanceFactor > 1 && value < root.left.value) {
    return rotateRight(root);
  }

  // 右子树的右侧插入情况，需要进行左旋转
  if (balanceFactor < -1 && value > root.right.value) {
    return rotateLeft(root);
  }

  // 左子树的右侧插入情况，需要进行先左旋后右旋
  if (balanceFactor > 1 && value > root.left.value) {
    root.left = rotateLeft(root.left);
    return rotateRight(root);
  }

  // 右子树的左侧插入情况，需要进行先右旋后左旋
  if (balanceFactor < -1 && value < root.right.value) {
    root.right = rotateRight(root.right);
    return rotateLeft(root);
  }

  return root;
}

// 创建平衡二叉树
function createBalancedBinaryTree(values) {
  let root = null;
  for (let i = 0; i < values.length; i++) {
    root = insertNode(root, values[i]);
  }
  return root;
}

// 示例用法
const values = [3, 7, 4, 2, 1, 5, 6];
const root = createBalancedBinaryTree(values);
console.log(root);
```



#### 判断平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

一棵高度平衡二叉树定义为：

> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
      1
     / \
    2   2
   / \
  3   3
 / \
4   4
```

返回 `false` 。

**解答一：自顶向下（递归+深度优先搜索）**

> **解题思路：** 
>
> 自顶向下的比较每个节点的左右子树的最大高度差，如果二叉树中每个节点的左右子树最大高度差小于等于 `1` ，即每个子树都平衡时，此时二叉树才是平衡二叉树
>
> 先计算深度，再判断是否平衡

**代码实现：**

```js
const isBalanced = function (root) {
  if(!root) return true
  //通过递归地判断每个节点的左右子树的深度差是否小于等于1，并且递归地判断左右子树是否也是平衡的二叉树
  return Math.abs(depth(root.left) - depth(root.right)) <= 1
        && isBalanced(root.left)
        && isBalanced(root.right)
}
//计算左右节点的深度
const depth = function (node) {
    if(!node) return -1
    return 1 + Math.max(depth(node.left), depth(node.right))
}
```

> **复杂度分析：**
>
> - 时间复杂度：O(nlogn)，计算 `depth` 存在大量冗余操作
> - 空间复杂度：O(n)

**解答二：自底向上（递归计算优化）**

> **解题思路：** 
>
> * 利用后续遍历二叉树（左右根），从底至顶返回子树最大高度，判定每个子树是不是平衡树 ，如果平衡，则使用它们的高度判断父节点是否平衡，并计算父节点的高度，如果不平衡，返回 `-1` 。
> * 遍历比较二叉树每个节点 的左右子树深度：
>   * 比较左右子树的深度，若差值大于 `1` 则返回一个标记 `-1` ，表示当前子树不平衡
>   * 左右子树有一个不是平衡的，或左右子树差值大于 `1` ，则二叉树不平衡
>   * 若左右子树平衡，返回当前树的深度（左右子树的深度最大值 `+1` ）
> * 优化分析：
>   * 该解法中，在计算深度的同时判断是否平衡：
>     * 先递归地判断左右子树是否平衡，再计算深度差。该方法在计算深度的同时，就可以判断子树是否平衡，避免了重复计算深度的过程，这样在某些情况下可以提高效率

**代码实现：**

```js
const isBalanced = function (root) {
    return balanced(root) !== -1
};
//计算以当前节点为根节点的子树的深度
const balanced = function (node) {
    if (!node) return 0
    const left = balanced(node.left)//递归地计算左右子树的深度
    const right = balanced(node.right)//递归地计算左右子树的深度
    //判断左右子树是否平衡,当前节点的左右子树的深度差是否小于等于1
    if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
        return -1
    }
    return Math.max(left, right) + 1
}
```

> **复杂度分析：**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)



## 完全二叉树

* 完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

### 判断是否为完全二叉树

给定一个二叉树，确定他是否是一个完全二叉树。

完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

> 样例图1：
>
> ![img](../images/完全二叉树1.png)
>
> * 输入：
>
> ```js
> {1,2,3,4,5,6}
> ```
>
> * 返回值：true
>
> 样例图2：
>
> ![img](../images/完全二叉树2.png)
>
> * 输入：
>
> ```js
> {1,2,3,4,5,6,7}
> ```
>
> * 返回值：true
>
> 样例图3：
>
> ![img](../images/完全二叉树3.png)
>
> 输入：
>
> ```js
> {1,2,3,4,5,null,6}
> ```
>
> 返回值：false

思路：**层次遍历**

> 对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历
>
> 从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树
>
> **具体做法：**
>
> - step 1：先判断空树一定是完全二叉树。
> - step 2：初始化一个队列辅助层次遍历，将根节点加入。
> - step 3：
>   - 逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记（代表访问到了叶子节点）；
>   - 若是后续还有访问，则说明叶子节点左子节点为空，右子节点不为空，不符合完全二叉树的性质。
> - step 4：否则，继续加入左右子节点进入队列排队，等待访问。

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return bool布尔型
 */
function isCompleteTree( root ) {
    let isEmptyNode = false; // 记录左子节点是否为空
    if(root == null) return true;
    const queue = [];
    queue.push(root);
    while(queue.length > 0) {
        const cur = queue.shift();
        if(cur === null) {
            isEmptyNode = true;
        }else {
            if(isEmptyNode) return false; // 上一个节点为空节点，而当前节点不为空，则表示左子节点为空，不符合
            queue.push(cur.left);
            queue.push(cur.right);
        }
    }
    return true;
}
module.exports = {
    isCompleteTree : isCompleteTree
};
```



## 红黑树

红黑树也是一种特殊的「二叉查找树」。

到目前为止我们学习的 AVL 树和即将学习的红黑树都是二叉查找树的变体，可见二叉查找树真的是非常重要基础二叉树，如果忘了它的定义可以先回头看看。

红黑树是一种比较难的数据结构，面试中很少有面试官让你手写一个红黑树，最多的话是考察你是否理解红黑树，以及为什么有了 AVL 树还需要红黑树，本部分就主要介绍这块。

### 什么是红黑树

红黑树是一种自平衡（并不是绝对平衡）的二叉查找树，它除了满足二分查找树的特点外，还满足以下条件：

- 节点是红色或黑色
- 根节点必须是黑色节点
- 所有的叶子节点都必须是值为 NULL 的黑节点
- 如果一个节点是红色的，则它两个子节点都是黑色的
- 从任一节点到达它的每个叶子节点的所有的路径，都有相同数目的黑色节点

![图片](../images/红黑树.png)

这些条条框框保证红黑树的自平衡，保证红黑树从根节点到达每一个叶子节点的最长路径不会超过最短路径的 2 倍。

而节点的路径长度决定着对节点的查询效率，这样我们确保了，最坏情况下的查找、插入、删除操作的时间复杂度不超过 O(logn) ，并且有较高的插入和删除效率。

### 红黑树 VS 平衡二叉树（AVL树）

- 插入和删除操作，一般认为红黑树的删除和插入会比 AVL 树更快。因为，红黑树不像 AVL 树那样严格的要求平衡因子小于等于1，这就减少了为了达到平衡而进行的旋转操作次数，可以说是牺牲严格平衡性来换取更快的插入和删除时间。
- 红黑树不要求有不严格的平衡性控制，但是红黑树的特点，使得任何不平衡都会在三次旋转之内解决。而 AVL 树如果不平衡，并不会控制旋转操作次数，旋转直到平衡为止。
- 查找操作，AVL树的效率更高。因为 AVL 树设计比红黑树更加平衡，不会出现平衡因子超过 1 的情况，减少了树的平均搜索长度。

## Trie 树

### 什么是 Trie 树

Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。

### Trie树的应用：字符串匹配

在搜索引擎中输入关键字，搜索引擎都会弹出下拉框，显示各种关键字提示，例如必应：

![图片](../images/字符串匹配(树).png)

必应是如何处理这一过程的喃？

或者，假设我们有n个单词的数据集，任意输入一串字符，如何在数据集中快速匹配出具有输入字符前缀的单词？

这样类似的问题还有很多，在日常开发中，遇到类似的问题，我们应该如何去处理？选择怎样的数据结构与算法？尤其是遇到大规模数据时，如何更高效的处理？

最简单的方法就是暴力，将数据集中的每个字符串，逐个字符的匹配输入字符，所有字符都匹配上则前缀匹配成功。这种方式也是我们开发当中最常用，最简单的方式，时间复杂度为 `O(m*n)` ，其中 `m` 为输入字符串长度， `n` 为数据集规模。

这个时间复杂度是很高的，当 `n` 很大时，暴力法性能就会很差，此时必须重新寻找合适的算法。

我们知道在树上查找、插入都比较方便，一般时间复杂度只与树的高度相关，我们可以通过树结构来处理，也就是我们要说的 Trie 树。其实，引擎搜索关键字提示底层也是通过 Trie 树实现的。

举个例子：假设数据集有：`are` 、 `add` 、 `adopt` 、`set` 、`so` ，它构键过程：

![图片](../images/字符串匹配树.png)

当所以的字符串插入完成，Trie树就构建完成了。

**Trie树的本质**是利用字符串的公共前缀，将重复的前缀合并在一起，其中根节点不包含任何信息，每个节点表示一个字符串中的字符，从根节点到叶节点的路径，表示一个字符串。

在字符串匹配的时候，我们只要按照树的结构从上到下匹配即可。

### 实现 Trie（前缀树）

实现一个 Trie (前缀树)，包含 `insert` , `search` , 和 `startsWith` 这三个操作。

**示例:**

```js
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

**说明:**

- 你可以假设所有的输入都是由小写字母 a-z 构成的。
- 保证所有输入均为非空字符串。

**解答：**

我们可以搭建一个初始 Trie 树结构：

```js
// Trie 树
var Trie = function() {};
// 插入
Trie.prototype.insert = function(word) {};
// 搜索
Trie.prototype.search = function(word) {};
// 前缀匹配
Trie.prototype.startsWith = function(prefix) {};
```

#### **如何存储一个 Trie 树**

首先，我们需要实现一个 Trie 树，我们知道，二叉树的存储（链式存储）是通过左右指针来实现的，即二叉树中的节点：

```js
function BinaryTreeNode(key) {
    // 保存当前节点 key 值
    this.key = key
    // 指向左子节点
    this.left = null
    // 指向右子节点
    this.right = null
}
```

在这里，它不止有两个字节点，它最多有 a-z 总共有26个子节点。最简单的实现是把她们保存在一个字典里：

- `isEnd` ：当前是否是结束节点
- `children` ：当前节点的子节点，这里我们使用 `key:value` 形式实现，`key` 为子节点字符，`value` 指向子节点的孩子节点

```json
var TrieNode = function() {
    // next 放入当前节点的子节点
    this.next = {};
    // 当前是否是结束节点
    this.isEnd = false;
};
```

所以：

```js
// Trie 树
var Trie = function() {
    this.root = new TrieNode()
};
```

#### **插入**

> - 首先判断插入节点是否为空，为空则返回
> - 遍历待插入字符，从根节点逐字符查找 Trie 树，如果字符查找失败则插入，否则继续查找下一个字符
> - 待插入字符遍历完成，设置最后字符的 `isEnd` 为 `true`
> - 返回插入成功

```js
Trie.prototype.insert = function(word) {
    if (!word) return false
    let node = this.root
    for (let i = 0; i < word.length; i++) {
        if (!node.next[word[i]]) {
            node.next[word[i]] = new TrieNode()
        }
        node = node.next[word[i]]
    }
    node.isEnd = true
    return true
};
```

#### **搜索**

> - 首先判断插入节点是否为空，为空则返回
> - 遍历待插入字符，从根节点逐字符查找 Trie 树，如果字符查找失败则返回false，否则继续查找下一个字符
> - 待插入字符遍历完成，返回最后一个节点 isEnd

```js
Trie.prototype.search = function(word) {
    if (!word) return false
    let node = this.root
    for (let i = 0; i < word.length; ++i) {
        if (node.next[word[i]]) {
            node = node.next[word[i]]
        } else {
            return false
        }
    }
    return node.isEnd
};
```

#### **前缀匹配**

```js
Trie.prototype.startsWith = function(prefix) {
    if (!prefix) return true
    let node = this.root
    for (let i = 0; i < prefix.length; ++i) {
        if (node.next[prefix[i]]) {
            node = node.next[prefix[i]]
        } else {
            return false
        }
    }
    return true
};
```



## 10 B 树、B+ 树（感兴趣进）

### 多叉查找树

既然二叉查找树已经理解了，那多叉查找树就很好理解了，它与二叉查找树唯一不同的是，它是多叉的。也就是说，多叉查找树允许一个节点存储多个元素，并且可以拥有多个子树。

![图片](../images/b加树.png)

为什么在有二叉查找树的情况下，还要有多叉查找树喃？

我们知道树的深度越高，时间复杂度越高，性能越差，多叉查找树相对于二叉查找树来说，每个节点不止能拥有两个子节点，每层存放的节点数可比二叉查找树多，自然多叉查找树的的深度就要更小，性能也就更好。例如主要用于各大存储文件系统与数据库系统中的 B 树。

### B 树(B-tree)

B 树，又称平衡多叉查找树。它是一种自平衡的多叉查找树。

如果一棵多路查找树满足以下规则，则称之为 B 树：

- 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
- 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M叉（或路），当M=2则是2叉树，M=3则是3叉）；
- 关键字数：枝节点（非根非叶）的关键字数量（K）应满足 (M+1)/2  < K < M
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

最后，我们使用一张图加深一下理解：

![图片](../images/b树.png)

### B+树

B+树与B树一样都是多叉平衡查找树（又名多路平衡查找树），B+树与B树不同的是：

- B+树改进了B树，让内结点（非叶节点）只作索引使用，去掉了其中指向data的指针，使得每个结点中能够存放更多的key， 因此能有更大的出度。

  这有什么用？这样就意味着存放同样多的key，树的层高能进一步被压缩，使得检索的时间更短

- 中间节点的元素数量与子树一致，而B树子树数量与元素数量多1

- 叶子节点是一个链表，可以通过指针顺序查找

![图片](../images/b+树.png)

## 编程题

### 二叉树路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 给定如下二叉树，以及目标和 `sum = 22` ，

```
          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
```

返回 `true` , 因为存在目标和为 `22` 的根节点到叶子节点的路径 `5->4->11->2`。

>  **解题思路：**
>
> * 只需要遍历整棵树
>
>   - 如果当前节点不是叶子节点，递归它的所有子节点，传递的参数就是 sum 减去当前的节点值；
>
>   - 如果当前节点是叶子节点，判断参数 sum 是否等于当前节点值，如果相等就返回 true，否则返回 false。

**代码实现：**

```js
var hasPathSum = function(root, sum) {
  // 根节点为空
  if (root === null) return false;
  
  // 叶节点 同时 sum 参数等于叶节点值
  if (root.left === null && root.right === null) return root.val === sum;

  // 总和减去当前值，并递归
  sum = sum - root.val
  return hasPathSum(root.left, sum) || hasPathSum(root.right sum);
};
```

### 翻转二叉树

给定一棵二叉树的根节点 `root`，请左右翻转这棵二叉树，并返回其根节点。

> 示例：
>
> ![img](../images/翻转二叉树.png)
>
> ```js
> 输入：root = [5,7,9,8,3,2,4]
> 输出：[5,9,7,4,2,3,8]
> ```

思路：**递归**

> * 二叉树的先序遍历
> * 当前节点为空,返回null
> * 交换左右子树
> * 依次遍历左右节点

```js
var mirrorTree = function(root) {
    if(root == null){
        return null
    }
    [[root.left,root.right]] = [[root.right,root.left]]
    mirrorTree(root.left)
    mirrorTree(root.right)
    return root
};
```



### 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```js
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```js
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？

**解答：**

一棵二叉树对称，则需要满足：根的左右子树是镜像对称的

也就是说，每棵树的左子树都和另外一颗树的右子树镜像对称，左子树的根节点值与右子树的根节点值相等

![图片](../images/对称二叉树.png)

所以，我们需要比较：

- 左右子树的根节点值是否相等
- 左右子树是否镜像对称

边界条件：

- 左右子树都为 `null` 时，返回 `true`
- 左右子树有一个 `null` 时，返回 `false`

**解法一：递归**

```js
const isSymmetric = function(root) {
    if(!root) return true
    var isEqual = function(left, right) {
        if(!left && !right) return true
        if(!left || !right) return false
        return left.val === right.val
         && isEqual(left.left, right.right)
         && isEqual(left.right, right.left)
    }
    return isEqual(root.left, root.right)
};
```

>  **复杂度分析：**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)

**解法二：迭代**

> 利用栈来记录比较的过程，实际上，递归就使用了调用栈，所以这里我们可以使用栈来模拟递归的过程
>
> - 首先根的左右子树入栈
> - 将左右子树出栈，比较两个数是否互为镜像
> - 如果左右子树的根节点值相等，则将左子树的 `left` 、右子树的 `right` 、左子树的 `right` 、右子树的 `left` 依次入栈
> - 继续出栈（一次出栈两个进行比较）…….
> - 注意入栈顺序，判断镜像对称，需要比较的是 左子树的 `left` 与 右子树的 `right`  ，左子树的 `right` 与 右子树的 `left` ，根据栈的先进后出特点，先入栈 左子树的 `left` 、右子树的 `right`  ，因此在出栈时，这两个才会进行对比；
>
> 依次循环出栈入栈，直到栈为空

```js
const isSymmetric = function(root) {
    if(!root) return true
    let stack = [root.left, root.right]
    while(stack.length) {
        let right = stack.pop()
        let left = stack.pop()
        if(left && right) {
            if(left.val !== right.val) return false
            stack.push(left.left)
            stack.push(right.right)
            stack.push(left.right)
            stack.push(right.left)
        } else if(left || right) {
            return false
        }
    }
    return true
};
```

>  **复杂度分析：**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)



### [合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

>  **示例 1：**
>
> ![image-20231209150916381](../images/合并二叉树.png)
>
> ```
> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
> 输出：[3,4,5,5,4,null,7]
> ```
>
> **示例 2：**
>
> ```
> 输入：root1 = [1], root2 = [1,2]
> 输出：[2,2]
> ```
>
>  
>
> **提示：**
>
> - 两棵树中的节点数目在范围 `[0, 2000]` 内
> - `-104 <= Node.val <= 104`

方法一：**递归（深度优先搜索）**

> 可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。
>
> 两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。
>
> 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；
>
> 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；
>
> 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。
>
> 对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    if(root1 == null) return root2;
    if(root2 == null) return root1;
    const node = new TreeNode(root1.val + root2.val);
    node.left = mergeTrees(root1.left, root2.left); // 注意合并后将递归新节点的子节点
    node.right = mergeTrees(root1.right, root2.right);
    return node;
};
```

方法二：**广度优先搜索**

> * 首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空
> * 如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。
> * 如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。
>
> 具体过程：
>
> * 使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。
>
> * 初始时将每个二叉树的根节点分别加入相应的队列。
>
> * 每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。
>
>   * 如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。
>
> * 如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：
>
>   * 如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；
>
>   * 如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。
>
> * 对于右子节点和右子树，处理方法与左子节点和左子树相同。
>
> ![](../images/合并二叉树.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function (root1, root2) {
    if (root1 == null) return root2;
    if (root2 == null) return root1;
    // 创建合并节点
    const mergedNode = new TreeNode(root1.val + root2.val);
    let queue = [], queue1 = [], queue2 = []; //创建三个队列分别存储合并节点和原始左右节点
    queue.push(mergedNode); // 存储节点
    queue1.push(root1);
    queue2.push(root2);
    // 遍历队列，直到队列为空，即为层次遍历结束
    while (queue1.length > 0 && queue2.length > 0) {
        // 获取队列节点，即合并节点和对比两棵树的对比节点
        const node = queue.shift(), node1 = queue1.shift(), node2 = queue2.shift();
        // 获取两个树的对比节点的左右子节点
        const left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;
        // 对两棵树的左节点进行对比
        if (left1 != null || left2 != null) {
            // 左节点左右节点都不为空，合并两个节点内容，并将三个树左节点入队列
            if (left1 != null && left2 != null) {
                const left = new TreeNode(left1.val + left2.val);
                node.left = left;
                queue.push(left);
                queue1.push(left1);
                queue2.push(left2);
            } else if (left1 != null) { // 树2 左节点为空，则将树1 左节点作为新树左节点
                node.left = left1;
            } else if (left2 != null) {// 树1 左节点为空，则将树2 左节点作为新树左节点
                node.left = left2;
            }
        }
        // 对两棵树的右节点进行对比
        if (right1 != null || right2 != null) {
               // 右节点左右节点都不为空，合并两个节点内容，并将三个树左节点入队列
            if (right1 != null && right2 != null) {
                const right = new TreeNode(right1.val + right2.val);
                node.right = right;
                queue.push(right);
                queue1.push(right1);
                queue2.push(right2);
            } else if (right1 != null) { // 树2 右节点为空，则将树1 右节点作为新树左节点
                node.right = right1;
            } else if (right2 != null) {// 树1 右节点为空，则将树2 右节点作为新树左节点
                node.right = right2;
            }
        }
       
    }
     return mergedNode;
};
```



### [二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solutions/531784/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![图片](../images/二叉树最先祖先.png)

**示例 1:**

```js
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```js
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

**说明**:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

**解法一：递归实现**

> 如果树为空树或 `p` 、 `q` 中任一节点为根节点，那么 `p` 、 `q` 的最近公共节点为根节点
>
> 如果不是，即二叉树不为空树，且 `p` 、 `q` 为非根节点，则递归遍历左右子树，获取左右子树的最近公共祖先，
>
> - 情况一：左子树和右子树均包含  p 节点或  q 节点，如果左子树包含的是  p 节点，那么右子树只能包含  q 节点，反之亦然，因为 p  节点和 q 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 x  就是我们要找的最近公共祖先；
> - 情况二：x 恰好是 p 节点或 q 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 x 就是我们要找的最近公共祖先
> - 情况三：p 节点和q节点都分布在 x 的左子树或右子树，则 x 是 p 节点和q 节点的最近公共祖先。
>   - 示例：搜索树中两个节点 `9` 和 `11` 的最近公共祖先![](../images/二叉树的最近公共祖先.gif)

**代码实现：**

```js
var lowestCommonAncestor = function(root, p, q) {
    let ans;
    const dfs = (root, p, q) => {
        if (root === null) return false;// 根节点为空，不存在公共祖先
        const lson = dfs(root.left, p, q); // 深度搜索左子树p、q 的公共祖先,其中 lson 代表 x 节点的左孩子
        const rson = dfs(root.right, p, q);// 深度搜索右子树p、q 的公共祖先,其中 Rson 代表 x 节点的右孩子
        if ((lson && rson) || ((root.val === p.val || root.val === q.val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root.val === p.val || root.val === q.val);
    }
    dfs(root, p, q);
    return ans;
};

```

>  **复杂度分析：**
>
>  - 时间复杂度：O(N)，其中 N是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(N)。
>  - 空间复杂度：O(N)，其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。



**解法二：哈希表存储父节点**

> * 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
>
> * 算法
>   * 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。
>   * 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。
>   * 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。

```js
var lowestCommonAncestor = function(root,p,q) {
    const parents = new Map() // 使用map存储访每一个节点的节点
    const visited = new Set() // 使用 set 存储p、q 访问的父节点查找链
    // 深度搜索，遍历每一个节点，并存储其父节点
    const dfs = function(root) {
        if(root.left !=null) {
            parents.set(root.left.value,root) // 保存当前值和它对应的根节点
            dfs(root.left)
        }
        if(root.right !=null) {
            parents.set(root.right.value,root) // 保存当前值和它对应的根节点
            dfs(root.right)
        }
    }
    
    const getLowestCommonAncestor = function(root,p,q){
        dfs(root) // 深度优先搜索记录每一个节点的父节点链条
        while(p!=null) {// 逆向查找 p 的父节点链条
            visited.push(p.value) // 保存p的访问路径
            p = parents.get(p.value) // 获取 p 的父亲节点
        }
        while(q!=null) {
            // p 的父节点访问路径中存在 q 节点，则 q 是最近公共祖先
            if(visited.has(q.value)) {
                return q
            }
            q = parents.get(q.value)
        }
        return null
    }
    getLowestCommonAncestor(root,p,q)
}
```

> * 复杂度分析
>
>   * 时间复杂度：O(N)，其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 p 和 q 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。
>
>   * 空间复杂度：O(N) ，其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)，哈希表存储每个节点的父节点也需要 O(N)的空间复杂度，因此最后总的空间复杂度为 O(N)。





### 二叉树指定节点间的最短距离

* 给定一个二叉树, 找到该树中两个指定节点间的最短距离

> **解答：**
>
> 求最近公共祖先节点，然后再求最近公共祖先节点到两个指定节点的路径，再求两个节点的路径之和

```js
const shortestDistance = function(root, p, q) {
    // 最近公共祖先
    let lowestCA = lowestCommonAncestor(root, p, q)
    // 分别求出公共祖先到两个节点的路经
    let pDis = [], qDis = []
    getPath(lowestCA, p, pDis)
    getPath(lowestCA, q, qDis)
    // 返回路径之和
    return (pDis.length + qDis.length)
}

// 最近公共祖先
const lowestCommonAncestor = function(root, p, q) {
    if(root === null || root === p || root === q) return root
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if(left === null) return right
    if(right === null) return left
    return root
}

const getPath = function(root, p, paths) {
    // 找到节点，返回 true
    if(root === p) return true
    // 当前节点加入路径中
    paths.push(root)
    let hasFound = false
    // 先找左子树
    if (root.left !== null)
        hasFound = getPath(root.left, p, paths)
    // 左子树没有找到，再找右子树
    if (!hasFound && root.right !== null)
        hasFound = getPath(root.right, p, paths)
    // 没有找到，说明不在这个节点下面，则弹出
    if (!hasFound)
        paths.pop()
    return hasFound
}
```

### 二叉搜索树中第K小的元素

给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 `k` 个最小的元素。

**说明：**你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
```

**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？

**解答：**

我们知道：中序遍历其实是对🌲进行排序操作 ，并且是按从小到大的顺序排序，所以本题就很简单了

**解题思路：** 中序遍历二叉搜索树，输出第 k 个既可

**代码实现（递归）：**

```js
const kthSmallest = function(root, k) {
    let res = null
    let inOrderTraverseNode = function(node) {
        if(node !== null && k > 0) {
            // 先遍历左子树
            inOrderTraverseNode(node.left)
            // 然后根节点
            if(--k === 0) {
                res = node.val
                return 
            }
            // 再遍历右子树
            inOrderTraverseNode(node.right)
        }
    }
    inOrderTraverseNode(root)
    return res
}
```

> **复杂度分析：**
>
> - 时间复杂度：O(k)
> - 空间复杂度：不考虑递归栈所占用的空间，空间复杂度为 O(1)



**代码实现（迭代）：**

```js
const kthSmallest = function(root, k) {
    let stack = []
    let node = root
    
    while(node || stack.length) {
        // 遍历左子树
        while(node) {
            stack.push(node)
            node = node.left
        }
      
        node = stack.pop()
        if(--k === 0) {
            return node.val
        }
        node = node.right
    }
    return null
}
```

> **复杂度分析：**
>
> - 时间复杂度：O(H+K)
> - 空间复杂度：空间复杂度为 O(H+K)



### 
