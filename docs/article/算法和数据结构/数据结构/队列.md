---
order: 3
category:
  - 数据结构和算法
tag:
  - 数据结构

---



# 队列

## 定义和特点

**队列（Queue）**：一种线性表数据结构，是一种只允许在表的一端进行插入操作，而在表的另一端进行删除操作的线性表。

* 队列是一种线性数据结构，具有先进先出（FIFO）的特性。
* 可以类比为排队买票，先来的人先被服务。
* 可以使用数组的`push()`和`shift()`方法来实现。

![队列结构](../../images/202405092254785.png)



## 基本操作

* 入队（Enqueue）：将元素放入队列的末尾。
* 出队（Dequeue）：从队列的头部移除元素，并返回移除的元素。
* 获取队头元素（Front）：返回队列头部的元素，并不移除该元素。
* 判断队列是否为空（isEmpty）：检查队列是否为空。

```javascript
class Queue {  
    // 初始化空队列  
    constructor(size = 100) {  
        this.size = size;  
        this.queue = new Array(size).fill(null); // 初始化队列数组  
        this.front = -1;  
        this.rear = -1;  
    }  
  
    // 判断队列是否为空  
    isEmpty() {  
        return this.front === this.rear;  
    }  
  
    // 判断队列是否已满  
    isFull() {  
        return (this.rear + 1) % this.size === this.front; // 使用取模操作来处理循环队列  
    }  
  
    // 入队操作  
    enqueue(value) {  
        if (this.isFull()) {  
            throw new Error('Queue is full');  
        } else {  
            this.rear = (this.rear + 1) % this.size; // 更新队尾指针，使用取模操作来处理循环  
            this.queue[this.rear] = value;  
        }  
    }  
  
    // 出队操作  
    dequeue() {  
        if (this.isEmpty()) {  
            throw new Error('Queue is empty');  
        } else {  
            let value = this.queue[this.front + 1]; // 注意JavaScript中数组索引从0开始  
            this.front = (this.front + 1) % this.size; // 更新队头指针，使用取模操作来处理循环  
            return value;  
        }  
    }  
  
    // 获取队头元素  
    frontValue() {  
        if (this.isEmpty()) {  
            throw new Error('Queue is empty');  
        } else {  
            return this.queue[(this.front + 1) % this.size]; // 注意JavaScript中数组索引从0开始，并使用取模操作  
        }  
    }  
  
    // 获取队尾元素  
    rearValue() {  
        if (this.isEmpty()) {  
            throw new Error('Queue is empty');  
        } else {  
            return this.queue[this.rear];  
        }  
    }  
}  
  
// 使用示例  
let q = new Queue(5);  
q.enqueue(1);  
q.enqueue(2);  
console.log(q.frontValue()); // 输出：1  
console.log(q.rearValue()); // 输出：2  
q.dequeue();  
console.log(q.frontValue()); // 输出：2
```



## 优先队列

> **优先队列（Priority Queue）**：一种特殊的队列。在优先队列中，元素被赋予优先级，当访问队列元素时，具有最高优先级的元素最先删除。
>
> 优先队列与普通队列最大的不同点在于 **出队顺序**。
>
> 优先队列的出队顺序跟入队顺序无关，优先队列是按照元素的优先级来决定出队顺序的：
>
> * 优先级高的元素优先出队，优先级低的元素后出队。
>
> 优先队列符合 **「最高级先出（First in, Largest out）」** 的规则。

![优先队列](../../images/优先队列.png)

###  **优先队列的适用场景**

- **数据压缩**：赫夫曼编码算法；
- **最短路径算法**：Dijkstra 算法；
- **最小生成树算法**：Prim 算法；
- **任务调度器**：根据优先级执行系统任务；
- **事件驱动仿真**：顾客排队算法；
- **排序问题**：查找第 k 个最小元素。

很多语言都提供了优先级队列的实现。比如，Java 的 `PriorityQueue`，C++ 的 `priority_queue` 等。Python 中也可以通过 `heapq` 来实现优先队列。下面我们来讲解一下优先队列的实现。

### **优先队列的实现方式**

优先队列所涉及的基本操作跟普通队列差不多，主要是 **「入队操作」** 和 **「出队操作」**。

而优先队列的实现方式也有很多种，除了使用「数组（顺序存储）实现」与「链表（链式存储）实现」之外，我们最常用的是使用 **「二叉堆结构实现」**优先队列。以下是三种方案的介绍和总结。

- **数组（顺序存储）实现优先队列**：入队操作直接插入到数组队尾，时间复杂度为 𝑂(1)。出队操作需要遍历整个数组，找到优先级最高的元素，返回并删除该元素，时间复杂度为 𝑂(𝑛)。
- **链表（链式存储）实现优先队列**：链表中的元素按照优先级排序，入队操作需要为待插入元素创建节点，并在链表中找到合适的插入位置，时间复杂度为 𝑂(𝑛)。出队操作直接返回链表队头元素，并删除队头元素，时间复杂度为 𝑂(1)。
- **二叉堆结构实现优先队列**：构建一个二叉堆结构，二叉堆按照优先级进行排序。入队操作就是将元素插入到二叉堆中合适位置，时间复杂度为 𝑂(log2⁡𝑛)。出队操作则返回二叉堆中优先级最大节点并删除，时间复杂度也是 𝑂(log⁡𝑛)。

下面是三种结构实现的优先队列入队操作和出队操作的时间复杂度总结。

|      | 入队操作时间复杂度 | 出队操作（取出优先级最高的元素）时间复杂度 |
| ---- | ------------------ | ------------------------------------------ |
| 堆   | 𝑂(log⁡𝑛)            | 𝑂(log⁡𝑛)                                    |
| 数组 | 𝑂(1)               | 𝑂(𝑛)                                       |
| 链表 | 𝑂(𝑛)               | 𝑂(1)                                       |

从上面的表格可以看出，使用「二叉堆」这种数据结构来实现优先队列是比较高效的。下面我们来讲解一下二叉堆实现的优先队列。

### **二叉堆实现的优先队列**

> 二叉堆实现的优先队列与二叉堆相同，详细知识参考二叉堆：[堆 | Sewen 博客 (sewar-x.github.io)](https://sewar-x.github.io/myblog/article/算法和数据结构/数据结构/堆.html)

通过手写二叉堆的方式实现优先队列。主要实现了以下五种方法：

- `heapAdjust`：将完全二叉树调整为二叉堆。
- `heapify`： 将数组构建为二叉堆方法（初始堆建立方法）。
- `heappush`：向堆中添加元素，也是优先队列的入队操作。
- `heappop`：删除堆顶元素，也是优先队列的出队操作，弹出优先队列中优先级最高的元素。
- `heapSort`：堆排序。

```typescript
class Heapq {
    // 堆调整方法：调整为大顶堆
    heapAdjust(nums: number[], index: number, end: number): void {
        let left = index * 2 + 1;// 当前节点左子节点
        let right = left + 1; // 右子节点
        while (left <= end) {
            // 当前节点为非叶子结点
            let max_index = index;
            if (nums[left] > nums[max_index]) {
                max_index = left;
            }
            if (right <= end && nums[right] > nums[max_index]) {
                max_index = right;
            }
            if (index === max_index) {
                // 如果不用交换，则说明已经交换结束
                break;
            }
            let temp = nums[index];
            nums[index] = nums[max_index];
            nums[max_index] = temp;
            // 继续调整子树
            index = max_index;
            left = index * 2 + 1;
            right = left + 1;
        }
    }

    // 将数组构建为二叉堆
    heapify(nums: number[]): void {
        let size = nums.length;
        // (size - 2) / 2 是最后一个非叶节点，叶节点不用调整，从最后一个非叶子节点开始调整
        for (let i = (size - 2) >> 1; i >= 0; i--) {
            // 调用调整堆函数
            this.heapAdjust(nums, i, size - 1);
        }
    }

    // 入队操作
    heappush(nums: number[], value: number): void {
        nums.push(value);
        let size = nums.length;
        let i = size - 1;
        // 寻找插入位置
        while ((i - 1) >> 1 >= 0) {
            let cur_root = (i - 1) >> 1;
            // value 小于当前根节点，则插入到当前位置
            if (nums[cur_root] > value) {
                break;
            }
            // 继续向上查找
            nums[i] = nums[cur_root];
            i = cur_root;
        }
        // 找到插入位置或者到达根位置，将其插入
        nums[i] = value;
    }

    // 出队操作
    heappop(nums: number[]): number {
        let size = nums.length;
        let top = nums[0];
        nums[0] = nums[size - 1];
        nums.pop();
        if (size > 0) {
            this.heapAdjust(nums, 0, size - 2);
        }
        return top;
    }

    // 升序堆排序
    heapSort(nums: number[]): number[] {
        this.heapify(nums);
        let size = nums.length;
        for (let i = 0; i < size; i++) {
            nums[0] = nums[size - i - 1];
            nums[size - i - 1] = top;
            this.heapAdjust(nums, 0, size - i - 2);
        }
        return nums;
    }
}

// 使用示例
const heap = new Heapq();
const nums = [3, 2, 5, 1, 7];
console.log(heap.heapSort(nums)); // 输出排序后的数组
```







## 算法题

| 题号 | 标题                                                         | 标签                     | 难度 |
| :--- | :----------------------------------------------------------- | :----------------------- | :--- |
| 0622 | [设计循环队列](https://leetcode.cn/problems/design-circular-queue/) | 设计、队列、数组、链表   | 中等 |
| 0346 | [数据流中的移动平均值](https://leetcode.cn/problems/moving-average-from-data-stream/) | 设计、队列、数组、数据流 | 简单 |
| 0225 | [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) | 栈、设计、队列           | 简单 |

### 优先队列

| 题号 | 标题                                                         | 标签                                                         | 难度 |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--- |
| 0703 | [数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/) | 树、设计、二叉搜索树、二叉树、数据流、堆（优先队列）         | 简单 |
| 0347 | [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) | 数组、哈希表、分治、桶排序、计数、快速选择、排序、堆（优先队列） | 中等 |
| 0451 | [根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/) | 哈希表、字符串、桶排序、计数、排序、堆（优先队列）           | 中等 |
| 0973 | [最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/) | 几何、数组、数学、分治、快速选择、排序、堆（优先队列）       | 中等 |
| 1296 | [划分数组为连续数字的集合](https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/) | 贪心、数组、哈希表、排序                                     | 中等 |
| 0239 | [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) | 队列、数组、滑动窗口、单调队列、堆（优先队列）               | 困难 |
| 0295 | [数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) | 设计、双指针、数据流、排序、堆（优先队列）                   | 困难 |
| 0023 | [合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | 链表、分治、堆（优先队列）、归并排序                         | 困难 |
| 0218 | [天际线问题](https://leetcode.cn/problems/the-skyline-problem/) | 树状数组、线段树、数组、分治、有序集合、扫描线、堆（优先队列） | 困难 |