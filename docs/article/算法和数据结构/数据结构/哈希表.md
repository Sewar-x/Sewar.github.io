---
order: 8
category:
  - 数据结构和算法
tag:
  - 数据结构
---
# 哈希表
哈希表（Hash Table）也称为散列表，是一种基于哈希函数（Hashing Function）实现的数据结构，用于存储键值对（key-value pairs）。

哈希函数将键（key）映射为索引（通常称为哈希值或散列值），然后使用该索引在数组中查找或存储值（value）。

## 思想

哈希表的关键思想是使用哈希函数，将键 key 映射到对应表的某个区块中。

可以将算法思想分为两个部分：

- **向哈希表中插入一个关键码值**：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。
- **在哈希表中搜索一个关键码值**：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。

哈希表的原理示例图如下所示：

![img](../../images/20220114120000.png)

## 特点

1. **快速访问**：如果哈希函数设计得当且数据分布均匀，哈希表可以在常数时间复杂度（O(1)）内完成查找、插入和删除操作。
2. **无序**：哈希表中的数据是无序的，它们按照哈希值存储，而不是按照键的自然顺序。
3. **动态扩展**：当哈希表中的数据量增加导致冲突（collision）过多时，哈希表可以动态地增加容量（即进行哈希表的扩容），以降低冲突的概率。
4. **空间效率**：哈希表的空间效率取决于哈希函数和负载因子（load factor）。负载因子是哈希表中元素的数量与哈希表大小的比值。较高的负载因子可能导致冲突增加，但可以减少空间浪费；较低的负载因子可以减少冲突，但需要更多的空间。



## **时间复杂度**

- 理想情况下（哈希函数设计得当且数据分布均匀），哈希表的查找、插入和删除操作的时间复杂度都是O(1)。但在实际中，由于冲突的存在，这些操作的时间复杂度可能会增加。在最坏情况下（如所有键的哈希值都相同），时间复杂度可能退化为O(n)，其中n是哈希表中的元素数量。
- 当哈希表进行扩容时，需要重新计算所有元素的哈希值并重新分配位置，这个时间复杂度是O(n)。但扩容操作通常不是频繁发生的，因此平均时间复杂度仍然接近O(1)。

**在哈希表中进行增删查改的时间复杂度都是 𝑂(1)** ，非常高效。

## **空间复杂度**

- 哈希表的空间复杂度是O(n)，其中n是哈希表中的元素数量。这是因为哈希表需要存储所有的键值对。
- 另外，为了处理冲突，哈希表可能会采用链表、红黑树等数据结构来存储具有相同哈希值的元素。这些数据结构会占用额外的空间。但相对于哈希表本身的空间复杂度来说，这些额外空间通常是可以接受的。

注意：以上分析假设哈希函数是确定性的（即对于相同的键总是返回相同的哈希值），并且哈希表的大小是固定的或可以动态调整的。在实际应用中，这些因素可能会影响哈希表的实际性能。



## 哈希表实现

以下以 TypeScript 简单实现：

```typescript
/* 键值对 Number -> String */
class Pair {
    public key: number;
    public val: string;

    constructor(key: number, val: string) {
        this.key = key;
        this.val = val;
    }
}

/* 基于数组实现的哈希表 */
class ArrayHashMap {
    // 桶，用于存储数据
    private readonly buckets: (Pair | null)[];

    constructor() {
        // 初始化数组，包含 100 个桶
        this.buckets = new Array(100).fill(null);
    }

    /* 哈希函数 */
    private hashFunc(key: number): number {
        return key % 100;
    }

    /* 查询操作 */
    public get(key: number): string | null {
        // 第一步：使用哈希函数计算桶的存储 index
        let index = this.hashFunc(key);
        // 第二步：往桶中根据 index 获取数据 
        let pair = this.buckets[index];
        if (pair === null) return null;
        return pair.val;
    }

    /* 添加操作 */
    public set(key: number, val: string) {
        // 使用哈希函数计算桶存储 Index
        let index = this.hashFunc(key);
        this.buckets[index] = new Pair(key, val);
    }

    /* 删除操作 */
    public delete(key: number) {
         // 使用哈希函数计算桶存储 Index
        let index = this.hashFunc(key);
        // 置为 null ，代表删除
        this.buckets[index] = null;
    }

    /* 获取所有键值对 */
    public entries(): (Pair | null)[] {
        let arr: (Pair | null)[] = [];
        for (let i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i]) {
                arr.push(this.buckets[i]);
            }
        }
        return arr;
    }

    /* 获取所有键 */
    public keys(): (number | undefined)[] {
        let arr: (number | undefined)[] = [];
        for (let i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i]) {
                arr.push(this.buckets[i].key);
            }
        }
        return arr;
    }

    /* 获取所有值 */
    public values(): (string | undefined)[] {
        let arr: (string | undefined)[] = [];
        for (let i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i]) {
                arr.push(this.buckets[i].val);
            }
        }
        return arr;
    }

    /* 打印哈希表 */
    public print() {
        let pairSet = this.entries();
        for (const pair of pairSet) {
            console.info(`${pair.key} -> ${pair.val}`);
        }
    }
}
```





## 哈希函数

**哈希函数（Hash Function）**：将哈希表中元素的关键键值映射为元素存储位置的函数。

哈希函数是哈希表中最重要的部分。一般来说，哈希函数会满足以下几个条件：

- 哈希函数应该易于计算，并且尽量使计算出来的索引值均匀分布。
- 哈希函数计算得到的哈希值是一个固定长度的输出值。
- 如果 Hash(key1)≠Hash(key2)，那么 key1、key2 一定不相等。
- 如果 Hash(key1)==Hash(key2)，那么 key1、key2 可能相等，也可能不相等（会发生哈希碰撞）。

在哈希表的实际应用中，关键字的类型除了数字类，还有可能是字符串类型、浮点数类型、大整数类型，甚至还有可能是几种类型的组合。一般我们会将各种类型的关键字先转换为整数类型，再通过哈希函数，将其映射到哈希表中。

### **哈希函数特点**

1. **确定性**：对于相同的输入，哈希函数总是产生相同的输出。这意味着给定相同的数据，哈希函数的输出是确定性的，可以重现和验证。
2. **唯一性**：理论上，不同的输入应该产生不同的哈希值。但在实际应用中，可能会因为哈希函数的设计或数据的特性，导致不同的输入产生相同的哈希值，这种情况称为哈希冲突。然而，好的哈希函数应该尽量减少哈希冲突的可能性。
3. **不可逆性**：从哈希值推导出原始输入是非常困难的，这要求哈希函数必须是单向的。即使知道哈希值，也无法找到与之对应的原始输入。这一特性使得哈希函数在密码学和数据完整性检测中具有重要应用。
4. **高效性**：哈希函数需要在短时间内计算出结果，以便在实际应用中快速处理大量数据。因此，哈希函数的设计通常注重计算效率。
5. **敏感性**：哈希函数对输入数据的微小变化非常敏感，即使是一个字符的改变也会导致哈希值的巨大变化。这种性质称为雪崩效应（Avalanche Effect），它确保了输入数据的细微变化会导致哈希值的显著变化，从而增强了哈希函数的安全性和数据唯一性。
6. **固定输出长度**：无论输入数据的大小如何，哈希函数总是产生固定长度的哈希值。这使得哈希函数适用于需要固定长度标识的场景。

### 哈希函数方法

而关于整数类型的关键字，通常用到的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。

### 常见简单哈希函数

哈希函数的方法有多种，以下是其中几种常见的哈希函数方法，并使用Markdown表示形式进行列举和说明：

#### 1. 直接定址法

**说明**：哈希函数为一次函数，即`H(key) = key` 或 `H(key) = a * key + b`，其中`H(key)`表示关键字为`key`对应的哈希地址，`a`和`b`都为常数。

**举例**：假设有一个从1到100岁的人口数字统计表，其中可以用年龄作为关键字，哈希函数可以取函数自身，即`H(key) = key`。

| 年龄 |  1   |  2   |  3   | ...  |  25  |  26  |  27  | ...  | 100  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 人数 | 3000 | 2000 | 5000 | ...  | 1050 | ...  | ...  | ...  | ...  |

#### 2. 数字分析法

**说明**：如果**关键字由多位字符或者数字组成**，就可以考虑抽取其中的2位或者多位作为该关键字对应的哈希地址。在取法上尽量**选择变化较多的位**，避免冲突发生。

**举例**：假设有一组员工ID，形如"EMP001", "EMP002", ...，"EMP999"。由于前三个字符都是"EMP"，且对于哈希地址来说并不重要，我们可以选择抽取后面的三位数字作为哈希地址。

#### 3. 平方取中法

**说明**：对关键字做平方操作，取中间得几位作为哈希地址。

**举例**：假设关键字为123，其平方为15129，取中间的两位或三位数字（如取中间两位为12）作为哈希地址。

#### 4. 折叠法

**说明**：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。此方法适合关键字位数较多的情况。

**举例**：假设关键字为9876543210，可以将其分割为987 654 321 0四部分（最后一部分只有一位），然后叠加求和（987+654+321+0=1962）作为哈希地址。注意这里要舍去进位。

#### 5. 除留余数法

**说明**：若已知整个哈希表的最大长度`m`，可以取一个不大于`m`的数`p`，然后对该关键字`key`做取余运算，即`H(key) = key % p`。如果长度不等，就选用随机数法。

**举例**：假设哈希表的最大长度为1000，我们可以选择一个不大于1000的素数`p`（如997），然后对关键字`key`进行取余运算得到哈希地址。

#### 6. 乘法哈希法

**说明**：将输入乘以一个常数，再取结果的小数部分或整数部分作为哈希值。这种方法能够在一定程度上消除冲突，并且适用于输入数据分布不均匀的情况。

**举例**：假设输入为关键字`key`，我们可以选择一个常数`A`（其值在0到1之间，如0.61803），然后计算`A * key`的小数部分作为哈希值。





### 常见哈希函数

在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2 和 SHA-3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。

|       特性       |                             MD5                              |                            SHA-1                             |                            SHA-2                             |                            SHA-3                             |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **散列长度**   |                            128位                             |                            160位                             |                  224位、256位、384位、512位                  |                  224位、256位、384位、512位                  |
|    **安全性**    |                 已被广泛认为不安全，存在冲突                 |                 已被广泛认为不安全，存在冲突                 | 比SHA-1更安全，但SHA-224和SHA-256在某些应用中可能被认为不够安全 |              目前认为是**最安全**的哈希算法之一              |
|     **设计**     |                    基于Merkle-Damgård结构                    |                    基于Merkle-Damgård结构                    | 基于Merkle-Damgård结构（SHA-224/256/384/512），但SHA-256b/512b使用不同设计 |             基于海绵函数（Sponge Function）设计              |
|     **速度**     |                              快                              |                             中等                             |                     较慢（与SHA-1相比）                      |             **最慢**（与MD5、SHA-1和SHA-2相比）              |
|     **应用**     | 已被许多系统用于密码存储和数据完整性校验，但不建议用于安全敏感的场景 | 已被广泛用于各种系统，包括TLS/SSL协议和Git版本控制系统，但已逐渐被更安全的算法替代 |      被广泛用于密码存储、数字签名、数据完整性校验等场景      | 越来越被接受为最安全的哈希算法之一，用于密码存储、数字签名等 |
|   **碰撞攻击**   |                       已被发现多个冲突                       |                       已被发现多个冲突                       |            目前未发现实际的冲突攻击，但理论上存在            |                   目前未发现实际的冲突攻击                   |
| **长度扩展攻击** |                    是（易受长度扩展攻击）                    |                    是（易受长度扩展攻击）                    | SHA-256和SHA-512不受长度扩展攻击，但SHA-224和SHA-384可能受影响 |                       不受长度扩展攻击                       |



**键值对的分布情况由哈希函数决定**。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：

```
index = hash(key) % capacity
```

观察以上公式，当哈希表容量 `capacity` 固定时，**哈希算法 `hash()` 决定了输出值**，进而决定了键值对在哈希表中的分布情况。



## 哈希冲突

> **哈希冲突（Hash Collision）**：不同的关键字通过同一个哈希函数可能得到同一哈希地址，即 key1≠key2，而 Hash(key1)==Hash(key2)，这种现象称为哈希冲突。

理想状态下，我们的哈希函数是完美的一对一映射，即一个关键字（key）对应一个值（value），不需要处理冲突。

但是一般情况下，不同的关键字 key 可能对应了同一个值 value，这就发生了哈希冲突。

设计再好的哈希函数也无法完全避免哈希冲突。所以就需要通过一定的方法来解决哈希冲突问题。

常用的哈希冲突解决方法主要是两类：**「开放地址法（Open Addressing）」** 和 **「链地址法（Chaining）」**。

### 哈希冲突解决方法

#### 开放定址法（也称为再散列法）

- 当关键字 `key` 的哈希地址 `p=H(key)` 出现冲突时，以 `p` 为基础，通过某种方式产生另一个哈希地址`p1`，如果`p1`仍然冲突，则继续产生`p2`，直到找出一个不冲突的哈希地址`pi`，将相应元素存入其中。

**冲突探测方法**

##### **线性探测**

**思想：**

冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

**操作：**

性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。

- **插入元素**：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。
- **查找元素**：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 `value` 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 `None` 。

**缺点：**

**线性探测容易产生“聚集现象”**：具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。

**实现：**

首先需要定义一个哈希表类，该类将包含一个用于存储元素的数组，以及一个哈希函数用于将键映射到数组索引。

当发生哈希冲突时，线性探测法将按顺序检查数组的下一个位置，直到找到一个空位置或到达数组的末尾并回到开始。

简单的实现不考虑负载因子或动态调整哈希表大小（resize）。在真实的哈希表实现中，当元素数量接近数组容量时，通常会进行 resize 操作以维护性能。

此外，这个实现也没有处理可能的哈希冲突极端情况（如所有键都哈希到同一个索引），这可能导致性能下降。在真实世界的应用中，需要更加复杂的策略来处理这些问题。

使用 TypeScript 实现：

```typescript
class HashTable<K extends string | number, V> {  
    // 用于存储键值对的数组，数组buckets[index][0] 存储 key，buckets[index][1] 存储 value
    private buckets: Array<[K, V] | null>;  
    // 哈希函数，用于将键映射到数组索引  
    private hashFunction: (key: K) => number;  
    // 数组大小  
    private capacity: number;  
  
    // 构造函数  
    constructor(capacity: number, hashFunction: (key: K) => number) {  
        this.capacity = capacity;  
        // 初始化数组，所有位置均为 null  
        this.buckets = new Array(capacity).fill(null);  
        this.hashFunction = hashFunction;  
    }  
  
    // 获取哈希索引  
    private getIndex(key: K): number {  
        // 调用哈希函数，然后对数组长度取模，以确保索引在数组范围内  
        return this.hashFunction(key) % this.capacity;  
    }  
  
    // 插入键值对  
    put(key: K, value: V): void {  
        // 获取初始哈希索引  
        let index = this.getIndex(key);  
  
        // 线性探测直到找到空位置或找到键的现有位置  
        while (this.buckets[index] !== null) {  
            // 如果找到了相同的键，则更新其值  
            if (this.buckets[index][0] === key) {  
                this.buckets[index][1] = value;  
                return;  
            }  
            // 否则，移动到下一个位置  
            index = (index + 1) % this.capacity; // 回到数组开始如果到达末尾  
        }  
  
        // 结束循环后，表示线性探测到空位置，在空位置插入新的键值对  
        this.buckets[index] = [key, value];  
    }  
  
    // 获取键的值  
    get(key: K): V | undefined {  
        // 获取初始哈希索引  
        let index = this.getIndex(key);  
  
        // 线性探测直到找到键的现有位置或空位置  
        while (this.buckets[index] !== null) {  
            // 如果找到了相同的键，则返回其值  
            if (this.buckets[index][0] === key) {  
                return this.buckets[index][1];  
            }  
            // 否则，移动到下一个位置  
            index = (index + 1) % this.capacity; // 回到数组开始如果到达末尾  
        }  
  
        // 结束循环后，表示线性探测没有找到键，则返回 undefined  
        return undefined;  
    }  
  
    // 其他方法，如删除、resize 等可以在此基础上添加  
}  
  
// 示例哈希函数（简单版本）  
function simpleHash(key: string | number): number {  
    let hash = 0;  
    if (typeof key === 'string') {  
        for (let i = 0; i < key.length; i++) {  
            hash = (hash << 5) - hash + key.charCodeAt(i);  
            hash |= 0; // 转换为 32 位整数  
        }  
    } else {  
        hash = key;  
    }  
    return hash;  
}  
  
// 使用示例  
const hashTable = new HashTable<string, number>(10, simpleHash);  
hashTable.put('apple', 1);  
hashTable.put('banana', 2);  
hashTable.put('carrot', 3);  
console.log(hashTable.get('apple')); // 输出: 1  
console.log(hashTable.get('carrot')); // 输出: 3
```





##### **二次探测（平方探测法）**

冲突发生时，在表的左右进行跳跃式探测，减少线性探测的堆积问题。

##### **再哈希法**

同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个等其他的哈希函数计算地址，直到不发生冲突为止。

**示例：**

例如，在长度为 11  的哈希表中已经填有关键字分别为 28 、49 、18 的记录（哈希函数为 Hash(key)=key mod  11）。现在将插入关键字为 38  的新纪录。根据哈希函数得到的哈希地址为 5 ，产生冲突。接下来分别使用这三种冲突解决方法处理冲突:

- 使用线性探测法：得到下一个地址 H(1)=(5+1)mod  11=6 ，仍然冲突；继续求出 H(2)=(5+2)mod  11=7 ，仍然冲突；继续求出 H(3)=(5+3)mod  11=8 ，8 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 8 的位置。
- 使用二次探测法：得到下一个地址 H(1)=(5+1×1)mod  11=6，仍然冲突；继续求出 H(2)=(5−1×1)mod  11=4，4 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 4 的位置。
- 使用伪随机数序列：假设伪随机数为 9，则得到下一个地址 H(1)=(9+5)mod  11=3，3 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 3 的位置。

使用这三种方法处理冲突的结果如下图所示：

![img](../../images/20220115162728.png)

#### 链地址法（也称为拉链法）

- 在哈希表的每个位置上设置一个链表，当发生冲突时，将元素插入到对应位置的链表中。
- 这种方法能够处理大规模的数据集，但对内存消耗较大。

**过程**：

我们假设哈希函数产生的哈希地址区间为 [0,*m*−1]，哈希表的表长为 m 。则可以将哈希表定义为一个有 m 个头节点组成的链表指针数组 T 。

- **插入操作**： 
  - 只需要通过哈希函数 Hash(key) 计算出对应的哈希地址 i ，然后将其以链表节点的形式插入到以 T[i] 为头节点的单链表中。在链表中插入位置可以在表头或表尾，也可以在中间。如果每次插入位置为表头，则插入操作的时间复杂度为 O(1) 。
- **查询操作**：
  - 只需要通过哈希函数 Hash(key) 计算出对应的哈希地址 i ，然后将对应位置上的链表整个扫描一遍，比较链表中每个链节点的键值与查询的键值是否一致。
  - 查询操作的时间复杂度跟链表的长度 k  成正比，也就是 O(k) 。对于哈希地址比较均匀的哈希函数来说，理论上讲，k=n / m ，其中 n  为关键字的个数，m  为哈希表的表长。
  - 链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都存储到同一个桶中，时间复杂度退化至 𝑂(𝑛) 。
  - <img src="../../images/image-20240507113218960.png" alt="image-20240507113218960" style="zoom:67%;" />
- **删除元素**：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。

链式地址存在以下局限性。

- **占用空间增大**：链表包含节点指针，它相比数组更加耗费内存空间。
- **查询效率降低**：因为需要线性遍历链表来查找对应元素。

**示例：**

举个例子来说明如何使用链地址法处理冲突。假设现在要存入的关键字集合 keys=[88,60,65,69,90,39,07,06,14,44,52,70,21,45,19,32] 。再假定哈希函数为 Hash(key)=key mod  13 ，哈希表的表长 m=13 ，哈希地址范围为 [0,*m*−1]。将这些关键字使用链地址法处理冲突，并按顺序加入哈希表中（图示为插入链表表尾位置），最终得到的哈希表如下图所示。

![img](../../images/20220115182535.png)



##### **链地址法实现**

实现一个基于链式地址（也称为分离链接法或开放寻址法的链表版本）的哈希表涉及两个主要部分：哈希函数和链表数组。

然而，传统的链式地址实际上是指将哈希冲突的键值对存储在链表中的方法，而不是在数组中直接进行开放寻址。我们可以模拟一个数组，其中每个索引位置都持有一个链表来处理哈希冲突。

使用 TypeScript 实现：

* 实现链表节
* 实现哈希表（包含：哈希值存储、哈希值获取）
* 实现哈希函数，用于计算哈希表存储的 key 值。 

```typescript
// 链表节点类  
class Node<K, V> {  
    key: K; // 键  
    value: V; // 值  
    next: Node<K, V> | null; // 指向下一个节点的指针  
  
    // 构造函数，用于创建新的链表节点  
    constructor(key: K, value: V, next: Node<K, V> | null = null) {  
        this.key = key;  
        this.value = value;  
        this.next = next;  
    }  
}  
  
// 哈希表类  
class HashTable<K extends string | number, V> {  
    // 存储链表头部的数组（桶）  
    private buckets: Array<Node<K, V> | null>;  
    // 哈希函数，用于将键映射到数组索引  
    private hashFunction: (key: K) => number;  
  
    // 构造函数，初始化哈希表  
    constructor(size: number, hashFunction: (key: K) => number) {  
        // 初始化桶数组，每个位置都是 null（没有链表）  
        this.buckets = new Array(size).fill(null);  
        this.hashFunction = hashFunction;  
    }  
  
    // 向哈希表中插入键值对  
    put(key: K, value: V): void {  
        // 计算键的哈希值，并转换为数组索引  
        const index = this.hashFunction(key) % this.buckets.length;  
        // 获取指定索引处的链表头部节点  
        let currentNode = this.buckets[index];  
  
        // 如果该索引处没有链表（即空桶）  
        if (!currentNode) {  
            // 创建一个新节点，并作为链表的头部  
            this.buckets[index] = new Node(key, value);  
        } else {  
            // 遍历链表，查找是否存在相同的键  
            let prevNode = null; // 前一个节点，用于在需要时更新指针  
            while (currentNode) {  
                // 如果找到了相同的键，则更新其值并返回  
                if (currentNode.key === key) {  
                    currentNode.value = value;  
                    return;  
                }  
                // 更新前一个节点  
                prevNode = currentNode;  
                // 移动到下一个节点  
                currentNode = currentNode.next;  
            }  
  
            // 如果链表遍历完仍未找到相同的键，则在链表末尾添加新节点  
            prevNode!.next = new Node(key, value);  
        }  
    }  
  
    // 从哈希表中检索键对应的值  
    get(key: K): V | undefined {  
        // 计算键的哈希值，并转换为数组索引  
        const index = this.hashFunction(key) % this.buckets.length;  
        // 获取指定索引处的链表头部节点  
        let currentNode = this.buckets[index];  
  
        // 遍历链表，查找是否存在相同的键  
        while (currentNode) {  
            if (currentNode.key === key) {  
                // 如果找到了相同的键，则返回其值  
                return currentNode.value;  
            }  
            // 移动到下一个节点  
            currentNode = currentNode.next;  
        }  
  
        // 如果链表遍历完仍未找到相同的键，则返回 undefined  
        return undefined;  
    }  
  
    // 其他方法，如 remove、size 等...（这里省略）  
}  
  
// 示例哈希函数（简单版本，仅用于演示），用于计算哈希表的存储 Key 
function simpleHash(key: string | number): number {  
    let hash = 0;  
    if (typeof key === 'string') {  
        // 如果键是字符串，则遍历其每个字符并计算哈希值  
        for (let i = 0; i < key.length; i++) {  
            hash = (hash << 5) - hash + key.charCodeAt(i);  
            hash |= 0; // 转换为 32 位整数  
        }  
    } else {  
        // 如果键是数字，则直接使用其值作为哈希值（这里可能需要根据具体需求进行调整）  
        hash = key;  
    }  
    return hash;  
}  
  
// 使用示例  
// 创建哈希表，初始化参数为：哈希表大小，哈希函数
const hashTable = new HashTable(10, simpleHash);  
hashTable.put('apple', 'fruit');  
hashTable.put('banana', 'fruit');  
hashTable.put('carrot', 'vegetable');  
console.log(hashTable.get('apple')); // 输出: fruit  
console.log(hashTable.get('carrot')); // 输出: vegetable
```



