---
order: 1
category:
  - 数据结构和算法
tag:
  - 算法
---
# 查找算法

![image-20231022173124646](../../images/算法-查找.png)



以下是几种常见的查找算法及其思想和时间、空间复杂度的概述：

|             查找算法             | 思想                                                         |                  时间复杂度                  |          空间复杂度          |
| :------------------------------: | :----------------------------------------------------------- | :------------------------------------------: | :--------------------------: |
|    顺序查找（Linear Search）     | 从列表的一端开始，逐个比较每个元素，直到找到所需元素或遍历完整个列表。 |                     O(n)                     |             O(1)             |
|    二分查找（Binary Search）     | 适用于**已排序的列表**。<br />首先比较列表中间的元素，如果找到所需元素则返回；否则根据中间元素与目标元素的大小关系，在列表的左半部分或右半部分继续查找，如此递归进行。 |                   O(log n)                   |             O(1)             |
| 斐波那契查找（Fibonacci Search） | 利用斐波那契数列的性质，在已排序的列表中查找所需元素。通过斐波那契数列确定查找范围，然后逐步缩小范围，直到找到所需元素。 |                   O(log n)                   |             O(1)             |
| 插值查找（Interpolation Search） | 适用于**已排序且元素分布均匀的列表**。<br />根据要查找的元素在列表中的大致位置，直接计算一个可能的中间位置进行查找，而非简单地取中间位置。 |               O(log n) 到 O(n)               |             O(1)             |
|     跳跃查找（Jump Search）      | 适用于**已排序且可以分组的列表**。<br />首先确定一个步长（跳跃距离），然后按照步长进行查找。当找到所在组时，再使用顺序查找确定具体位置。 |                  O(sqrt(n))                  |             O(1)             |
|  树表查找（Tree Table Search）   | 基于树形数据结构（如二叉查找树、平衡二叉树、B树等）进行查找。通过树的层级结构，可以快速定位到所需元素。 | 取决于树的具体类型和平衡情况，但通常优于O(n) | 取决于树的具体类型和存储结构 |
|       哈希查找（Hashing）        | 通过哈希函数将键映射到表中的一个位置，然后在该位置查找所需元素。哈希查找的平均时间复杂度为常数时间，但最坏情况可能退化到O(n)。 |        平均情况：O(1)，最坏情况：O(n)        | 取决于哈希表的实现和存储需求 |

**注意**：

1. 时间复杂度：上述时间复杂度均为平均或最好/最坏情况下的估计，具体实现和输入数据可能会影响实际性能。
2. 空间复杂度：对于大多数查找算法，空间复杂度通常为O(1)，因为它们通常只需要存储少量变量或指针。但对于某些算法（如树表查找和哈希查找），空间复杂度可能因数据结构的不同而有所变化。
3. 实际应用中，选择哪种查找算法取决于数据的性质、规模、存储结构以及查询的频繁程度等因素。

----



## 折半查找

**适用范围： 有序表**

**思想：**

* 在有序表中，首先选取有序表的中间值 mid
* 比较中间值 mid 和 目标值 target 大小
  * mid < target: 递归查找左子表
  * mid > target:  递归查找右子表

**示例**

> 对静态查找表`{5,13,19,21,37,56,64,75,80,88,92}`采用折半查找算法查找关键字为  21  的过程为：
>
> ![img](../../images/2-1G016102104D7.png)
> 
>
> 如上所示，指针 low 和 high 分别指向查找表的第一个关键字和最后一个关键字，指针 mid 指向处于 low 和 high 指针中间位置的关键字。在查找的过程中每次都同 mid 指向的关键字进行比较，由于整个表中的数据是有序的，因此在比较之后就可以知道要查找的关键字的大致位置。
>
> 例如:
>
> 1. 在查找关键字 21 时，首先同 56 作比较，由于`21 < 56`，而且这个查找表是按照升序进行排序的，所以可以判定如果静态查找表中有 21 这个关键字，就一定存在于 low 和 mid 指向的区域中间。
> 2. 再次遍历时需要更新 high 指针和 mid 指针的位置，令 high 指针移动到 mid 指针的左侧一个位置上，同时令 mid 重新指向 low 指针和 high 指针的中间位置。
>
> ![img](../../images/2-1G016102250N2.png)
> 
>
> 3. 用 21 同 mid 指针指向的 19 作比较，`19 < 21`，所以可以判定 21 如果存在，肯定处于 mid 和 high 指向的区域中。所以令 low 指向 mid 右侧一个位置上，同时更新 mid 的位置。
>
> ![img](../../images/2-1G01610231cS.png)
>
> 
>
> 4. 当第三次做判断时，发现 mid 就是关键字 21 ，查找结束。
>
> 注意：在做查找的过程中，如果 low 指针和 high 指针的中间位置在计算时位于两个关键字中间，即求得 mid 的位置不是整数，需要统一做取整操作。

**实现**

```javascript
function BinarySearch(array,target,left, right){
	let  mid  
	let  left = 0
	let  right = array.length - 1
	while(left  <= right) {
		mid = (left + right)/2
		if(array[mid] === array[target]){
			return array[mid]
		}else if(array[mid] > array[target]) {
			right = mid - 1 
        }else {
        	left = mid + 1 
        }
	}
	return false
}
```



---



## 插值查找

插值查找（Interpolation Search）是一种基于二分查找的改进算法，主要用于**在已排序的数组中查找某个特定的元素**。

插值查找的基本思想是利用元素在数组中的分布情况，通过计算一个“预测值”来作为比较的基准，而不是简单地取数组的中间值。如果目标值比预测值小，则在数组的左半部分继续查找；反之，则在右半部分查找。

**插值查找的实现思路**：

1. 假设数组已经排序。
2. 计算目标值在数组中的预测位置。这通常是通过一个插值公式来完成的，该公式考虑了目标值和数组边界值的关系。
3. 如果预测位置上的元素就是目标值，则返回该位置。
4. 如果预测位置上的元素比目标值大，则在数组的左半部分继续查找。
5. 如果预测位置上的元素比目标值小，则在数组的右半部分继续查找。
6. 重复步骤 2-5，直到找到目标值或确定目标值不存在于数组中。

**插值查找通过以下公式来计算预测位置：**

```
pos = low + ⌊((high - low) / (arr[high] - arr[low])) * (target - arr[low])⌋
```

>  这个公式的解释如下：
>
> - `low` 和 `high` 是当前查找范围的边界（初始时 `low = 0`，`high = arr.length - 1`）。
> - `arr[high] - arr[low]` 是当前查找范围内元素的最大差值。
> - `target - arr[low]` 是目标值与当前查找范围起始值的差值。
> - 通过将 `(target - arr[low])` 除以 `(arr[high] - arr[low])`，我们得到了一个介于 0 和 1 之间的比例因子。这个比例因子反映了目标值在当前查找范围内的相对位置。
> - 然后，我们将这个比例因子乘以 `(high - low)`，即当前查找范围的长度，得到一个偏移量。
> - 最后，将这个偏移量加到 `low` 上，就得到了预测位置 `pos`。





如果数组中的元素分布均匀，那么插值查找通常会比二分查找更快，因为它能够更精确地定位到目标值可能存在的位置。

然而，如果数组中的元素分布不均匀，或者存在大量的重复元素，那么插值查找可能会退化为线性查找，因为预测位置可能会频繁地指向错误的方向。

```javascript
function interpolationSearch(arr, target) {  
    let low = 0;  
    let high = arr.length - 1;  
  
    // 确保数组不为空  
    if (high >= low) {  
        // 当查找范围不为空时循环  
        while (low <= high && target >= arr[low] && target <= arr[high]) {  
            // 计算预测位置  
            let pos = low + Math.floor(((high - low) / (arr[high] - arr[low])) * (target - arr[low]));  
  
            // 检查预测位置上的元素  
            if (arr[pos] === target) {  
                return pos; // 找到目标值，返回其位置  
            }  
  
            // 如果预测位置上的元素比目标值大，则在左半部分继续查找  
            if (arr[pos] > target) {  
                high = pos - 1;  
            }  
            // 否则，在右半部分继续查找  
            else {  
                low = pos + 1;  
            }  
        }  
    }  
  
    // 如果未找到目标值，返回-1  
    return -1;  
}  
  
// 示例用法  
let arr = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47];  
let target = 18;  
let result = interpolationSearch(arr, target);  
if (result !== -1) {  
    console.log(`目标值 ${target} 在数组中的位置是 ${result}`);  
} else {  
    console.log(`目标值 ${target} 不在数组中`);  
}
```

---



## 跳跃查找

跳跃查找（Jump Search）是一种在有序数组中查找特定元素的搜索算法。

该算法的思想是通过固定大小的步长（或称为“块”）来跳过数组中的某些元素，从而减少了需要检查的元素数量。当搜索的步长过大时，算法会退化为线性搜索；当步长过小时，算法接近于二分搜索。因此，选择适当的步长是跳跃查找的关键。

**跳跃查找的实现思路如下**：

1. 首先，确定一个块大小（步长）。这通常与数组的长度有关，比如可以是 `Math.floor(Math.sqrt(arr.length))`。
2. 从数组的第一个元素开始，以确定的步长向前跳跃，直到找到一个大于或等于目标值的元素，或者超过了数组的末尾。
3. 如果找到了目标值，则返回其索引。
4. 如果没有找到目标值，但在某一步长内发现当前元素大于目标值，则在该步长内的元素中进行线性搜索。
5. 如果在整个数组中都没有找到目标值，则返回 -1。



```javascript
function jumpSearch(arr, target) {  
    // 数组必须是有序的  
    // 初始化左右边界  
    let left = 0;  
    let right = arr.length - 1;  
  
    // 计算步长，通常取数组长度的平方根  
    let step = Math.floor(Math.sqrt(arr.length));  
  
    // 找到目标值可能所在的块  
    while (arr[Math.min(right, left + step)] < target && left < right) {  
        left += step; // 跳跃到下一个块  
    }  
  
    // 现在，在目标值可能所在的块内进行线性搜索  
    while (left <= right && arr[left] < target) {  
        left++; // 逐个检查元素  
    }  
  
    // 如果找到了目标值，返回其索引  
    if (arr[left] === target) {  
        return left;  
    }  
  
    // 如果没有找到目标值，返回 -1  
    return -1;  
}  
  
// 示例用法  
let arr = [2, 3, 4, 10, 40]; // 注意：此数组需要是有序的  
let target = 10;  
let result = jumpSearch(arr, target);  
if (result !== -1) {  
    console.log(`目标值 ${target} 在数组中的位置是 ${result}`);  
} else {  
    console.log(`目标值 ${target} 不在数组中`);  
}
```



---



## 二叉排序树（二叉查找树）

> 详细参考博客：[树 | Sewen 博客 (sewar-x.github.io)](https://sewar-x.github.io/myblog/article/算法和数据结构/数据结构/树.html#二叉查找树-bst树)

## 平衡二叉树（AVL树）

> 详细参考博客：[树 | Sewen 博客 (sewar-x.github.io)](https://sewar-x.github.io/myblog/article/算法和数据结构/数据结构/树.html#平衡二叉查找树-avl树)

---





---

## JavaScript 中查找方法

### 数组中查找方法

###### [find()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

* 实现

  * ```javascript
    Array.prototype.find = function(fn) {
        for (let i = 0; i < this.length; i++) {
            if (fn(this[i])) 
            	return this[i]
        }
    }
    ```

###### [findIndex()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)

* 实现

  * ```javascript
    Array.prototype.find = function(fn) {
        for (let i = 0; i < this.length; i++) {
            if (fn(this[i])) 
            	return i
        }
    }
    ```

###### [indexOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)

* 实现

  * ```javascript
    Array.prototype.indexOf = function(value,start) {
    	if(this === null || !value)								// 不允许null调用或则查找值为空
    		return -1
    	let i = 0,length = this.length
    	if(start && typeof start === 'number') {				// 处理第二个参数
    		if(start > length) return -1
    		i = (start < 0 ? Math.max(0,length+start):start);
    	}
        for(;i<length;i++){										//	从第二个参数位置起从前往后查找
           if(this[i]===value){
               return i;
           }
       	}
       	return -1;
    }
    ```

  * 注意

    * `indexOf` 使用[strict equality](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Using_the_Equality_Operators) (无论是 ===, 还是 triple-equals操作符都基于同样的方法)进行判断 `searchElement与`数组中包含的元素之间的关系
    * 第二个参数 start (开始查找的位置) 规则:
      * 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。
      * 如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。
      * 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。
      * 如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.

###### [lastIndexOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)

* 实现

```javascript
    Array.prototype.lastIndexOf = function(value,start) {
    	if(this === null || !value)	
    		return -1
    	let i=this.length-1
    	if(start && typeof start === 'number') {
    		if(start < 0) {
    			if(Math.abs(start) > i) {
    				return -1
    			}else {
    				i = i+start
    			}
    		}else {
    			i = i-start
    		}
    	}
    	for(;i>=0;i--){										//	从第二个参数位置起从后往前查找
           if(this[i]===value){
               return i;
           }
       	}
       	return -1
    }
```

###### [includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)