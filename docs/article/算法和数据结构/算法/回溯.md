---
order: 6
category:
  - 数据结构和算法
tag:
  - 算法
---
# 回溯算法

![image-20231022182640484](../../images/算法-回溯.png)

## 思想

采用试错的思想，在搜索尝试过程中寻找问题的解，当探索到某一步时，发现原先的选择并不满足求解条件，或者还需要满足更多求解条件时，就退回一步（回溯）重新选择，这种走不通就退回再走的技术称为「回溯法」，而满足回溯条件的某个状态的点称为「回溯点」。

回溯算法采用了一种 **「走不通就回退」** 的算法思想。

回溯算法通常用简单的递归方法来实现，在进行回溯过程中更可能会出现两种情况：

1. 找到一个可能存在的正确答案；
2. 在尝试了所有可能的分布方法之后宣布该问题没有答案。

## 回溯算法解题步骤

回溯算法的基本思想是：**以深度优先搜索的方式，根据产生子节点的条件约束，搜索问题的解。当发现当前节点已不满足求解条件时，就「回溯」返回，尝试其他的路径。**

在写回溯算法时具体步骤如下：

1. **定义问题解空间**：
   - 明确问题的解空间，即所有可能的解或候选解的集合。
   - 解空间树是回溯法求解过程中组织搜索的一个数据结构。树上的每一个节点表示问题求解过程中可能到达的一个中间状态，它包含有关搜索路径和求得中间解的全部信息。
2. **确定搜索策略：**
   - 选择合适的搜索策略，如**深度优先搜索或广度优先搜索。**在回溯法中，通常使用深度优先搜索。
   - 确定搜索的起始点和结束条件。
3. **设计递归函数：**
   - 设计一个或多个递归函数，用于遍历解空间树。
   - 递归函数应接收当前路径（当前解的部分表示）和当前搜索状态（如当前节点的索引）作为参数。
4. **剪枝优化：**
   - 在搜索过程中，如果发现当前搜索路径的某个节点不可能导出问题的解，则应及时停止对该节点的进一步搜索，即“剪枝”。
   - 剪枝可以显著提高算法的效率，减少不必要的搜索。
5. **回溯：**
   - 当搜索到某一节点时，如果已不满足求解条件，就“退回”一步（即回溯），尝试其他可能。
   - 回溯操作通常涉及撤销在当前节点所做的选择，并返回到其父节点或前一个状态。
6. **存储和输出结果：**
   - 当找到一个有效解时，将其存储起来（例如，添加到结果列表中）。
   - 在所有可能的解都被找到后，输出或返回结果。
7. **处理边界条件和特殊情况：**
   - 在编写回溯算法时，要注意处理边界条件和特殊情况。
   - 例如，当搜索到解空间的边界时，可能需要特殊处理；当某些选择无效或导致重复解时，需要跳过这些选择。

## 回溯算法的通用模板

```javascript
// 假设有一个目标函数用于判断某个路径是否满足条件  
function isValid(path, currentChoice) {  
    // 在这里编写你的逻辑，判断当前选择是否有效  
    // 返回true表示有效，返回false表示无效  
    // 例如，如果我们在解决组合问题，可能会检查路径是否已包含当前选择  
}  
  
/* 
 回溯函数 
 choices：表示当前层可以选择的选项列表。
 path：表示从根节点到当前节点的路径。默认为空数组。
 start：表示从哪个索引开始选择。默认为0，但在某些问题中，你可能希望从某个特定的索引开始以避免重复。
**/
function backtrack(choices, path = [], start = 0) {  
    //这是一个你需要定义的函数或逻辑，用于判断何时停止在当前路径上进一步探索
    // 如果满足某种条件（例如，路径长度达到目标长度），则记录或处理路径  
    if (满足结束条件(path)) {  
        // 例如，将路径添加到结果集中  
        results.push(path.slice()); // 注意：使用slice()创建路径的副本，避免直接修改原数组  
    }  

    //遍历当前层的所有选择
    for (let i = start; i < choices.length; i++) {  
        // 做选择  
        const currentChoice = choices[i];  
        // 判断当前选择是否有效  
        if (isValid(path, currentChoice)) {  
            // 将当前选择添加到路径中  
            path.push(currentChoice);  
            // 进入下一层决策树  
            backtrack(choices, path, i + 1); // 注意：在某些问题中，可能需要从i+1开始以避免重复  
            // 撤销选择,无论是否进入下一层，都需要撤销当前选择，以便在for循环的下一轮尝试其他选择。  
            path.pop();  
        }  
    }  
}  
  
// 初始化结果集和选择列表  
let results = [];  
let choices = [...]; // 填充你的选择列表  
  
// 调用回溯函数  
backtrack(choices);  
  
// 打印结果  
console.log(results);
```

**详细解释**：

1. **isValid函数**：这是一个辅助函数，用于判断某个选择在当前路径下是否有效。你需要根据问题的具体需求来实现这个函数。
2. **backtrack函数**：这是回溯算法的核心函数。
   - 参数：
     - `choices`：表示当前层可以选择的选项列表。
     - `path`：表示从根节点到当前节点的路径。默认为空数组。
     - `start`：表示从哪个索引开始选择。默认为0，但在某些问题中，你可能希望从某个特定的索引开始以避免重复。
   - **满足结束条件**：这是一个你需要定义的函数或逻辑，用于判断何时停止在当前路径上进一步探索。例如，在组合问题中，你可能希望当路径长度达到某个目标值时停止。
   - for循环：遍历当前层的所有选择。
     - **做选择**：将当前选择添加到路径中。
     - **判断有效性**：使用`isValid`函数检查当前选择是否有效。
     - **递归调用**：如果当前选择有效，则进入下一层决策树。注意，在某些问题中，你可能需要从`i+1`开始以避免重复选择。
     - **撤销选择**：无论是否进入下一层，都需要撤销当前选择，以便在for循环的下一轮尝试其他选择。
3. **结果集和选择列表**：在调用`backtrack`函数之前，你需要初始化结果集和选择列表。结果集用于存储所有满足条件的路径，选择列表包含所有可能的选项。
4. **调用回溯函数并打印结果**：最后，调用`backtrack`函数并打印结果集。



## 算法题

| 题号 | 标题                                                         | 标签                                   | 难度 |
| :--- | :----------------------------------------------------------- | :------------------------------------- | :--- |
| 0046 | [全排列](https://leetcode.cn/problems/permutations/)         | 数组、回溯                             | 中等 |
| 0047 | [全排列 II](https://leetcode.cn/problems/permutations-ii/)   | 数组、回溯                             | 中等 |
| 0051 | [N皇后](https://leetcode.cn/problems/n-queens/)              | 数组、回溯                             | 困难 |
| 0037 | [解数独](https://leetcode.cn/problems/sudoku-solver/)        | 数组、哈希表、回溯、矩阵               | 困难 |
| 0022 | [括号生成](https://leetcode.cn/problems/generate-parentheses/) | 字符串、动态规划、回溯                 | 中等 |
| 0017 | [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/) | 哈希表、字符串、回溯                   | 中等 |
| 0784 | [字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/) | 位运算、字符串、回溯                   | 中等 |
| 0039 | [组合总和](https://leetcode.cn/problems/combination-sum/)    | 数组、回溯                             | 中等 |
| 0040 | [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) | 数组、回溯                             | 中等 |
| 0078 | [子集](https://leetcode.cn/problems/subsets/)                | 位运算、数组、回溯                     | 中等 |
| 0090 | [子集 II](https://leetcode.cn/problems/subsets-ii/)          | 位运算、数组、回溯                     | 中等 |
| 0473 | [火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/) | 位运算、数组、动态规划、回溯、状态压缩 | 中等 |
| 1593 | [拆分字符串使唯一子字符串的数目最大](https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/) | 哈希表、字符串、回溯                   | 中等 |
| 1079 | [活字印刷](https://leetcode.cn/problems/letter-tile-possibilities/) | 哈希表、字符串、回溯、计数             | 中等 |
| 0093 | [复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/) | 字符串、回溯                           | 中等 |
| 0079 | [单词搜索](https://leetcode.cn/problems/word-search/)        | 数组、回溯、矩阵                       | 中等 |
| 0679 | [24 点游戏](https://leetcode.cn/problems/24-game/)           | 数组、数学、回溯                       | 困难 |

### [全排列](https://leetcode.cn/problems/permutations/)