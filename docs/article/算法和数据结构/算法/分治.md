---
order: 7
category:
  - 数据结构和算法
tag:
  - 算法
---
# 分治

 **把规模大的问题不断分解为子问题，使得问题规模减小到可以直接求解为止。**

<img src="../../images/20220413153059.png" alt="img" style="zoom:80%;" />

## 分治算法和递归算法

从定义上来看，分治算法的思想和递归算法的思想是一样的，都是把规模大的问题不断分解为子问题。

其实，分治算法和递归算法的关系是包含与被包含的关系，可以看做： **递归算法 ∈ 分治算法**。

分治算法从实现方式上来划分，可以分为两种：「递归算法」和「迭代算法」。

<img src="../../images/20220414093828.png" alt="img" style="zoom:50%;" />

一般情况下，分治算法比较适合使用递归算法来实现。

但除了递归算法之外，分治算法还可以通过迭代算法来实现。比较常见的例子有：快速傅里叶变换算法、二分查找算法、非递归实现的归并排序算法等等。

## 分治算法的适用条件

分治算法能够解决的问题，一般需要满足以下 444 个条件：

1. **可分解**：原问题可以分解为若干个规模较小的相同子问题。
2. **子问题可独立求解**：分解出来的子问题可以独立求解，即子问题之间不包含公共的子子问题。
3. **具有分解的终止条件**：当问题的规模足够小时，能够用较简单的方法解决。
4. **可合并**：子问题的解可以合并为原问题的解，并且合并操作的复杂度不能太高，否则就无法起到减少算法总体复杂度的效果了。

## 分治算法的基本步骤

使用分治算法解决问题主要分为 333 个步骤：

1. **分解**：把要解决的问题分解为成若干个规模较小、相对独立、与原问题形式相同的子问题。
2. **求解**：递归求解各个子问题。
3. **合并**：按照原问题的要求，将子问题的解逐层合并构成原问题的解。



## 分治案例

* [归并排序](https://sewar-x.github.io/myblog/article/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
* [二分查找](https://sewar-x.github.io/myblog/article/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE.html#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE)



## 算法题

| 题号          | 标题                                                         | 标签                                     | 难度 |
| :------------ | :----------------------------------------------------------- | :--------------------------------------- | :--- |
| 0014          | [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/) | 字典树、字符串                           | 简单 |
| 0169          | [多数元素](https://leetcode.cn/problems/majority-element/)   | 数组、哈希表、分治、计数、排序           | 简单 |
| 0053          | [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | 数组、分治、动态规划                     | 中等 |
| 0241          | [为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) | 递归、记忆化搜索、数学、字符串、动态规划 | 中等 |
| 0050          | [Pow(x, n)](https://leetcode.cn/problems/powx-n/)            | 递归、数学                               | 中等 |
| 剑指 Offer 33 | [二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) | 栈、树、二叉搜索树、递归、二叉树、单调栈 | 中等 |
| 0004          | [寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/) | 数组、二分查找、分治                     | 困难 |
| 0023          | [合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | 链表、分治、堆（优先队列）、归并排序     | 困难 |



###   [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

题解参考：[字符串 | Sewen 博客 (sewar-x.github.io)](https://sewar-x.github.io/myblog/article/算法和数据结构/数据结构/字符串.html#最长公共前缀)

### [多数元素](https://leetcode.cn/problems/majority-element/)

#### 题目

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```



#### 解法一：分治

**思路**

如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。

**证明**

使用反证法来证明这个结论：假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 `l / 2` + `r / 2` 次（其中 l 和 r 分别是左半部分和右半部分的长度）。由于 `l / 2` + `r / 2` <= `(l + r) / 2`，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。

**算法**

1. 分解：将数组分成左右两部分，分别求出左半部分的众数 `a1` 以及右半部分的众数 `a2`，随后在 `a1` 和 `a2` 中选出正确的众数。分解直到所有的子问题都是长度为 `1` 的数组。
2. 求解：长度为 `1` 的子数组中唯一的数显然是众数，直接返回即可。
3. 合并：
   * 如果回溯后某区间的长度大于 `1`，我们必须将左右子区间的值合并。
   * 如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。
   * 否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。

 ```typescript
 function majorityElement(nums: number[]): number {
   return majorityElementDiv(nums, 0, nums.length - 1)
 };
 
 
 
 /**
  * 递归拆分
  * @param nums 
  * @param start 
  * @param end 
  * @returns 
  */
 function majorityElementDiv(nums: number[], start: number, end: number): number {
   //当拆分到只有一个元素时，返回当前元素
   if (start === end) {
     return nums[start]
   }
   // 计算中间值下标，从中间拆分
   let mid = Math.floor((end + start) / 2)
   // 递归拆分左半部分并计算出左半部分出现最多的数
   let leftMaxNum = majorityElementDiv(nums, start, mid)
   // 递归拆分右半部分并计算出右半部分出现最多的数
   let rightMaxNum = majorityElementDiv(nums, mid + 1, end)
   // 左右出现次数最多的数字相同，返回
 
   if (leftMaxNum === rightMaxNum) {
     return leftMaxNum
   }
   // 计算左侧出现次数最多的数字
   let leftCount = countMaxTimeNum(nums, leftMaxNum, start, end)
   // 计算右侧出现次数最多的数字
   let rightCount = countMaxTimeNum(nums, rightMaxNum, start, end)
 
   return leftCount > rightCount ? leftCount : rightCount
 }
 
 /**
  * 统计在 [start,end] 范围内，num 在 nums 中出现次数
  * @param nums 
  * @param num 
  * @param start 
  * @param end 
  * @returns 
  */
 function countMaxTimeNum(nums: number[], num: number, start: number, end: number): number {
   let count = 0
   for (let i = start; i <= end; i++) {
     if (nums[i] === num) {
       count++
     }
   }
   return count
 }
 ```





#### 解法二：哈希表

1. 遍历数组；
2. 使用哈希表 map 存储每一个元素和它出现的次数，以元素为Key，元素出现次数为 value 存储；
3. 遍历哈希表 map 中查找出现次数最多的元素，返回

```typescript
function majorityElement(nums: number[]): number {
  if (nums.length <= 2) return nums[0]
  let numMap = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (numMap.has(nums[i])) {
      let num = numMap.get(nums[i])
      num++
      numMap.set(nums[i], num)
    } else {
      numMap.set(nums[i], 1)
    }
  }
  let maxNum = 0
  let maxNumKey = nums[0]
  for (let [key, value] of numMap) {
    if (value > maxNum) {
      maxNum = value
      maxNumKey = key
    }
  }
  return maxNumKey
};
```

**复杂度**

* 时间复杂度：O(n) ，其中 n 是数组 `nums` 的长度。
* 空间复杂度：O(n) 。

#### 解法三：排序+中位数

如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为  `n/2`  的元素（下标从 0 开始）一定是众数。

```typescript
function majorityElement(nums: number[]): number {
  let sortNums = nums.sort((a,b)=> a-b)
  return sortNums[Math.floor(nums.length/2)]
};
```

**复杂度**

* 时间复杂度：O(nlog⁡n) 。将数组排序的时间复杂度为 O(nlog⁡n) 。

* 空间复杂度：O(log⁡n) 。如果使用语言自带的排序算法，需要使用 O(log⁡n) 的栈空间。如果自己编写堆排序，则只需要使用 O(1)  的额外空间。



 