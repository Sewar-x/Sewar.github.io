---
order: 1
category:
  - 数据结构和算法
tag:
  - 算法
---

# 位运算

## 二进制

> **二进制数（Binary）**：由 00 和 11 两个数码来表示的数。二进制数中每一个 0  或每一个 1 都称为一个「位（Bit）」。
>
> ![二进制数](https://qcdn.itcharge.cn/images/202405132135165.png)

* 十进制数：有 0∼9  共 10  个数字，进位规则是「满十进一」。
* 二进制数: 只有 0  和 1  两个数码，它的进位规则是「逢二进一」。



## 二进制转换

### 二进制转十进制数

* 在十进制数中，数字 2749(10)  可以理解为 2×1000+7×100+4×10+9∗1 ，相当于 2×10^3+7×10^2+4×10^1+9×10 ，即 2000+700+40+9=2749(10) 。

* 在二进制数中，01101010(2) 可以看作为 (0×2^7)+(1×2^6)+(1×2^5)+(0×2^4)+(1×2^3)+(0×2^2)+(1×2^1)+(0×2^0)(，即 0+64+32+0+8+0+2+0=106(10) 。

![二进制数转十进制数](../../images/202405132136456.png)

### 十进制转二进制数

十进制数转二进制数的方法是：**除二取余，逆序排列法**。

以十进制数中的 106(10)  为例。

![十进制数转二](../../images/image-20240519101213088.png)

反向遍历每次计算的余数，依次是 0 、1、1、0、1、0、1、0 即 01101010(2)

---



## 位运算基础操作

| 运算符 | 描述           | 规则                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| `&`    | 按位与运算符   | （**同1为1**）只有对应的两个二进位都为 1  时，结果位才为 1   |
| `|`    | 按位或运算符   | （**遇1为1**）只要对应的两个二进位有一个为 1 时，结果位就为 1 |
| `<<`   | 左移运算符     | 将二进制数的各个二进位全部左移若干位。`<<` 右侧数字指定了移动位数，高位丢弃，低位补 0 |
| `>>`   | 右移运算符     | 对二进制数的各个二进位全部右移若干位。`>>` 右侧数字指定了移动位数，低位丢弃，高位补 0 |
| `^`    | 按位异或运算符 | （**同0异1**）对应的两个二进位相异时，结果位为 1 ，二进位相同时则结果位为 0 。 |
| `~`    | 取反运算符     | 对二进制数的每个二进位取反，使数字 1  变为 0 ，0  变为 1     |

### 按位与运算

> **按位与运算（AND）**：按位与运算符为 `&`。其功能是对两个二进制数的每一个二进位进行与运算。

- **按位与运算规则**：（ **同1为1**）只有对应的两个二进位都为 1 时，结果位才为 1 。
  - `1 & 1 = 1`
  - `1 & 0 = 0`
  - `0 & 1 = 0`
  - `0 & 0 = 0`

举个例子，对二进制数 01111100(2) 与 00111110(2) 进行按位与运算，结果为 00111100(2) ，如图所示：

![按位与运算](../../images/202405132137023.png)

### 按位或运算

> **按位或运算（OR）**：按位或运算符为 `|`。其功能对两个二进制数的每一个二进位进行或运算。

- 按位或运算规则：（**遇1为1**）只要对应的两个二进位有一个为 1 时，结果位就为 1。
  - `1 | 1 = 1`
  - `1 | 0 = 1`
  - `0 | 1 = 1`
  - `0 | 0 = 0`

举个例子，对二进制数 01001010(2) 与 01011011(2) 进行按位或运算，结果为 01011011(2) ，如图所示：

![按位或运算](../../images/202405132137593.png)

### 按位异或运算

> **按位异或运算（XOR）**：按位异或运算符为 `^`。其功能是对两个二进制数的每一个二进位进行异或运算。

- **按位异或运算规则**：（**同0异1**）对应的两个二进位相异时，结果位为 1 ，二进位相同时则结果位为 0 。
- `0 ^ 0 = 0`
- `1 ^ 0 = 1`
- `0 ^ 1 = 1`
- `1 ^ 1 = 0`

举个例子，对二进制数 01001010(2) 与 01000101(2) 进行按位异或运算，结果为 00001111(2) ，如图所示：

![按位异或运算](../../images/202405132137874.png)

### 取反运算

> **取反运算（NOT）**：取反运算符为 `~`。其功能是对一个二进制数的每一个二进位进行取反运算。

- 取反运算规则：使数字 1 变为 0，0 变为 1。
  - `~0 = 1`
  - `~1 = 0`

举个例子，对二进制数 01101010(2)  进行取反运算，结果如图所示：

![取反运算](../../images/202405132138853.png)

### 左移运算和右移运算

> **左移运算（SHL）**： 左移运算符为 `<<`。其功能是对一个二进制数的各个二进位全部左移若干位（高位丢弃，低位补 00）。

举个例子，对二进制数 01101010(2)  进行左移 11 位运算，结果为 11010100(2) ，如图所示：

![左移运算](../../images/202405132138841.png) 

> **右移运算（SHR）**： 右移运算符为 `>>`。其功能是对一个二进制数的各个二进位全部右移若干位（低位丢弃，高位补 00）。

举个例子，对二进制数 01101010(2)  进行右移 1 位运算，结果为 00110101(2) ，如图所示：

![右移运算](../../images/202405132138348.png)

---



## 位运算的应用

### 交换两个数

通过按位异或运算可以实现交换两个数的目的（只能用于交换两个整数）。

```javascript
假设 a=10,b=20，请交换 a,b 的值
a = a ^ b
b = a ^ b
a = a ^ b
结果： a=20, b=10
```

**原理**：异或运算 **同 0 异 1**，且满足交换率

```javascript
a = a ^ b
b = a ^ b =  (a ^ b) ^ b =  a ^ (b ^ b) =  a ^ 0 = a
a = a ^ b =  (a ^ b) ^ a =  (a ^ a) ^ b = 0 ^ b = b
```





### 判断整数奇偶

一个整数：

* 只要是偶数，其对应二进制数的末尾一定为 0 
* 只要是奇数，其对应二进制数的末尾一定为 1 

所以，通过与 1  进行按位与运算，即可判断某个数是奇数还是偶数。（1 的二进制为 00000001，因此某数与 1 进行按位与运算，将只保留最后一位数）

- `(x & 1) == 0` 为偶数
- `(x & 1) == 1` 为奇数



### 二进制数选取指定位

**问题**：从一个二进制数 𝑋 中取出某几位，使取出位置上的二进位保留原值，其余位置为 0 。

**方案**：可以使用另一个二进制数 𝑌 ，使该二进制数上对应取出位置为 1 ，其余位置为 0 。然后令两个数进行按位与运算（`X & Y`），即可得到想要的数。

**原理**：按位与运算（ **同1为1**）都为1的位，结果为1。因此其余位与 0 按位与运算后都为 0。

**示例**：比如我们要取二进制数 𝑋=01101010(2) 的末尾 4 位，则只需将 𝑋=01101010(2) 与 𝑌=00001111(2) (末尾 4  位为 1 ，其余位为 0) 进行按位与运算，即 `01101010 & 00001111 == 00001010`。其结果 00001010 就是我们想要的数（即二进制数 01101010(2) 的末尾 4  位）。



### 将指定位设置为 1 

**问题**：把一个二进制数 𝑋  中的某几位设置为 1，其余位置保留原值。

**方案**：可以使用另一个二进制数 𝑌 ，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位或运算（`X | Y`），即可得到想要的数。

**原理**：按位或运算（ **遇1为1**）与 1 运算的位，结果为1。因此其余位与 0 按位与运算后都保留。

**示例**：比如我们想要将二进制数 𝑋=01101010(2) 的末尾 4 位设置为 1 ，其余位置保留原值，则只需将 𝑋=01101010(2) 与 𝑌=00001111(2)（末尾 4  位为 1，其余位为 0 ）进行按位或运算，即 `01101010 | 00001111 = 01101111`。其结果 01101111 就是我们想要的数（即将二进制数 01101010(2) 的末尾 4 位设置为 1 ，其余位置保留原值）



### 反转指定位

**问题**：把一个二进制数 𝑋 的某几位进行反转。

**方案**：可以使用另一个二进制数 𝑌 ，使得该二进制上对应选取位置为 1 ，其余位置为 0 。然后令两个数进行按位异或运算（`X ^ Y`），即可得到想要的数。

**原理**：异或运算（同 0 异1 ）

**示例**：比如想要将二进制数 𝑋=01101010(2) 的末尾 4 位进行反转，则只需将 𝑋=01101010(2)  与 𝑌=00001111(2) （末尾 4  位为 1 ，其余位为 0 ）进行按位异或运算，即 `01101010 ^ 00001111 = 01100101`。其结果 01100101就是我们想要的数（即将二进制数 𝑋=01101010(2) 的末尾 4  位进行反转）。



### 将二进制最右侧为 1 的二进位改为 0

**问题**：将一个二进制数 𝑋  最右侧为 1  的二进制位改为 0 。

**方案**：只需通过 `X & (X - 1)` 的操作即可完成。

**示例**：比如 𝑋=01101100(2) ，𝑋−1=01101011(2) ，则 `X & (X - 1) == 01101100 & 01101011 == 01101000`，结果为 01101000(2) （即将 𝑋  最右侧第三位数为 1  的二进制为改为 0 ）



### 计算二进制中二进位为 1 的个数

从以上操作中得知：通过 `X & (X - 1)` 我们可以将二进制 𝑋 最右侧为 1 的二进制位改为 0 ，那么如果我们不断通过 `X & (X - 1)` 操作，最终将二进制 𝑋 变为 0 ，并统计执行次数，则可以得到二进制中二进位为 1 的个数。

```javascript
function countOne(x){
    let count = 0;
    while(x>0) {
        x = x & (x-1);
        count ++
    }
    return count
}
```



### 求 2 的n 幂次方

**方案**：`1 << n`

**原理**：通过将 1 左移 n 位即  2 的 n 幂次方





### 判断某数是否为 2 的幂次方

**方案**：通过判断 `X & (X - 1) == 0` 是否成立，即可判断 𝑋 是否为 2  的幂次方。

**原理**：

- 凡是 2 的幂次方，其二进制数的某一高位为 1，并且仅此高位为 1，其余位都为 0。比如：4(10)=00000100(2) 、8(10)=00001000(2) 。
- 不是 2 的幂次方，其二进制数存在多个值为 1 的位。比如：5(10)=00000101(2) 、6(10)=00000110(2) 。

接下来使用 `X & (X - 1)` 操作，将原数对应二进制数最右侧为 1 的二进位改为 0 之后，得到新值：

- 如果原数是 2  的幂次方，则通过 `X & (X - 1)` 操作之后，新值所有位都为 0 ，值为 0 。
- 如果该数不是 2  的幂次方，则通过 `X & (X - 1)` 操作之后，新值仍存在不为 0 的位，值肯定不为  0。

所以可以通过是否为 0 即可判断该数是否为 2 的幂次方。

### 位运算的常用操作总结

| 功能                                   | 位运算                                                       | 示例                                                         |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **求 2 的 n 幂次方**                   | 通过将 1 左移 n 位即  2 的 n 幂次方                          | 2的4次方：2^4 = 8<br />`00000001 << 4 = 00001000  `          |
| **判断整数奇偶**                       | 通过与 1  进行按位与运算:<br /> `(x & 1) == 0` 为偶数;<br /> `(x & 1) == 1` 为奇数 |                                                              |
| **交换两个数**                         | 按位异或运算                                                 | `a = a ^ b`<br/>`b = a ^ b`<br/>`a = a ^ b`                  |
| **二进制数选取指定位**                 | 使用另一个二进制数 𝑌 ，使该二进制数上对应取出位置为 1 ，其余位置为 0 。<br />然后令两个数进行按位与运算（`X & Y`） | x=01101010 , 取最后四位<br />`01101010 & 00001111 == 00001010` |
| **将指定位设置为 1**                   | 使用另一个二进制数 𝑌 ，使得该二进制上对应选取位置为 1，其余位置为 0。<br />然后令两个数进行按位或运算（`X | Y`） | 𝑋=01101010，后四位为1，其余保留<br />`01101010 | 00001111 = 01101111` |
| **反转指定位**                         | 使用另一个二进制数 𝑌 ，使得该二进制上对应选取位置为 1 ，其余位置为 0 。<br />然后令两个数进行按位异或运算（`X ^ Y`） | 𝑋=01101010(2) 的末尾 4 位进行反转<br />`01101010 ^ 00001111 = 01100101` |
| **将二进制最右侧为 1 的二进位改为 0**  | `X & (X - 1)`                                                | 𝑋=01101100 <br />`X & (X - 1) == 01101100 & 01101011 == 01101000` |
| **判断某数是否为 2 的幂次方**          | 判断 `X & (X - 1) == 0` 是否成立                             |                                                              |
| **从右边开始，把最后一个 1 改写成  0** | `x & (x - 1)`                                                | `100101000 -> 100100000`                                     |
| **去掉右边起第一个 1  的左边**         | `x & (x ^ (x - 1))` 或 `x & (-x)`                            | `100101000 -> 1000`                                          |
| **去掉最后一位**                       | `x >> 1`                                                     | `101101 -> 10110`                                            |
| **取右数第k 位**                       | `x >> (k - 1) & 1`                                           | `1101101 -> 1, k = 4`                                        |
| **取末尾 3 位**                        | `x & 7`                                                      | `1101101 -> 101`                                             |
| **取末尾 𝑘 位**                        | `x & 15`                                                     | `1101101 -> 1101, k = 4`                                     |
| **只保留右边连续的 1**                 | `(x ^ (x + 1)) >> 1`                                         | `100101111 -> 1111`                                          |
| **右数第 𝑘 位取反**                    | `x ^ (1 << (k - 1))`                                         | `101001 -> 101101, k = 3`                                    |
| **在最后加一个 0**                     | `x << 1`                                                     | `101101 -> 1011010`                                          |
| **在最后加一个 1**                     | `(x << 1) + 1`                                               | `101101 -> 1011011`                                          |
| **把右数第 𝑘位变成  0**                | `x & ~(1 << (k - 1))`                                        | `101101 -> 101001, k = 3`                                    |
| **把右数第 𝑘 位变成  1**               | `x | (1 << (k - 1))`                                         | `101001 -> 101101, k = 3`                                    |
| **把右边起第一个 0 变成 1 **           | `x | (x + 1)`                                                | `100101111 -> 100111111`                                     |
| **把右边连续的 0  变成  1**            | `x | (x - 1)`                                                | `11011000 -> 11011111`                                       |
| **把右边连续的 1 变成 0**              | `x & (x + 1)`                                                | `100101111 -> 100100000`                                     |
| **把最后一位变成 0 **                  | `x | 1 - 1`                                                  | `101101 -> 101100`                                           |
| **把最后一位变成 1**                   | `x | 1`                                                      | `101100 -> 101101`                                           |
| **把末尾 𝑘位变成 1**                   | `x | (1 << k - 1)`                                           | `101001 -> 101111, k = 4`                                    |
| **最后一位取反**                       | `x ^ 1`                                                      | `101101 -> 101100`                                           |
| **末尾 𝑘 位取反**                      | `x ^ (1 << k - 1)`                                           | `101001 -> 100110, k = 4`                                    |

### 二进制枚举子集

**问题**：给定一个集合 𝑆*S*，枚举其所有可能的子集。

**方案**：对于一个元素个数为  n  的集合 𝑆 来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 1  来表示选取该元素，用数字 0 来表示不选取该元素。

那么我们就可以用一个长度为 𝑛  的二进制数来表示集合 𝑆 或者表示 𝑆 的子集。其中二进制的每一个二进位都对应了集合中某一个元素的选取状态。对于集合中第 𝑖 个元素来说，二进制对应位置上的 1  代表该元素被选取，0  代表该元素未被选取。

**示例**：比如长度为 5  的集合 𝑆={5,4,3,2,1} ，我们可以用一个长度为 5  的二进制数来表示该集合：

* 二进制数 11111(2) 就表示选取集合的第 1  位、第 2 位、第  3 位、第 4  位、第  5 位元素，也就是集合 {5,4,3,2,1} ，即集合 𝑆 本身。
* 二进制数 10101(2) 就表示选取集合的第 1  位、第 3  位、第 5  位元素，也就是集合 {5,3,1} 。
* 二进制数 01001(2) 就表示选取集合的第 1 位、第 4  位元素，也就是集合 {4,1} 。

**结论**：对于长度为 𝑛  的集合 𝑆  ，只需要枚举 0∼2^𝑛−1 （共 2^𝑛 种情况），即可得到集合  S 的所有子集。

```javascript
function subsets(S) {  
        const n = S.length; // n 为集合 S 的元素个数  
        const subSets = []; // subSets 用于保存所有子集  
  
        // 枚举 0 ~ 2^n - 1  
        for (let i = 0; i < (1 << n); i++) {  
            const subSet = []; // subSet 用于保存当前子集  
  
            // 枚举第 i 位元素  
            for (let j = 0; j < n; j++) {  
                // 如果第 i 位元素对应二进位为 1，则表示选取该元素  
                if ((i >> j) & 1) {  
                    subSet.push(S[j]); // 将选取的元素加入到子集 subSet 中  
                }  
            }  
  
            subSets.push(subSet); // 将子集 subSet 加入到所有子集数组 subSets 中  
        }  
  
        return subSets; // 返回所有子集  
    }  
```

---



## 算法题

| 题号 | 标题                                                         | 标签                                       | 难度 |
| :--- | :----------------------------------------------------------- | :----------------------------------------- | :--- |
| 0504 | [七进制数](https://leetcode.cn/problems/base-7/)             | 数学                                       | 简单 |
| 0405 | [数字转换为十六进制数](https://leetcode.cn/problems/convert-a-number-to-hexadecimal/) | 位运算、数学                               | 简单 |
| 0190 | [颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)   | 位运算、分治                               | 简单 |
| 1009 | [十进制整数的反码](https://leetcode.cn/problems/complement-of-base-10-integer/) | 位运算                                     | 简单 |
| 0191 | [位1的个数](https://leetcode.cn/problems/number-of-1-bits/)  | 位运算、分治                               | 简单 |
| 0371 | [两整数之和](https://leetcode.cn/problems/sum-of-two-integers/) | 位运算、数学                               | 中等 |
| 0089 | [格雷编码](https://leetcode.cn/problems/gray-code/)          | 位运算、数学、回溯                         | 中等 |
| 0201 | [数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/) | 位运算                                     | 中等 |
| 0338 | [比特位计数](https://leetcode.cn/problems/counting-bits/)    | 位运算、动态规划                           | 简单 |
| 0136 | [只出现一次的数字](https://leetcode.cn/problems/single-number/) | 位运算、数组                               | 简单 |
| 0137 | [只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) | 位运算、数组                               | 中等 |
| 0260 | [只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) | 位运算、数组                               | 中等 |
| 0268 | [丢失的数字](https://leetcode.cn/problems/missing-number/)   | 位运算、数组、哈希表、数学、二分查找、排序 | 简单 |
| 1349 | [参加考试的最大学生数](https://leetcode.cn/problems/maximum-students-taking-exam/) | 位运算、数组、动态规划、状态压缩、矩阵     | 困难 |
| 0645 | [错误的集合](https://leetcode.cn/problems/set-mismatch/)     | 位运算、数组、哈希表、排序                 | 简单 |
| 0078 | [子集](https://leetcode.cn/problems/subsets/)                | 位运算、数组、回溯                         | 中等 |
| 0090 | [子集 II](https://leetcode.cn/problems/subsets-ii/)          | 位运算、数组、回溯                         | 中等 |